// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 14.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace Unchase.OData.ConnectedService.Templates
{
    using System;
    using System.IO;
    using System.Diagnostics;
    using System.Globalization;
    using System.Linq;
    using System.Xml;
    using System.Xml.Linq;
    using System.Collections.Generic;
    using Microsoft.OData.Edm.Csdl;
    using Microsoft.OData.Edm;
    using Microsoft.OData.Edm.Vocabularies;
    using Microsoft.OData.Edm.Vocabularies.V1;
    using Microsoft.OData.Edm.Vocabularies.Community.V1;
    using System.Text;
    using System.Net;
    using System.Data.Metadata.Edm;
    using Microsoft.VisualStudio.Debugger.Interop;

    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    internal partial class ODataT4CodeGenerator : ODataT4CodeGeneratorBase
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public virtual string TransformText()
        {
            /*
            OData Client T4 Template ver. #VersionNumber#
            Copyright (c) Microsoft Corporation
            Updated by Unchase (https://github.com/unchase)
            All rights reserved. 
            MIT License
            Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

            The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

            THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
            */

            try
            {
                CodeGenerationContext context;
                if (!string.IsNullOrWhiteSpace(this.Edmx))
                {
                    context = new CodeGenerationContext(this.Edmx, this.NamespacePrefix)
                    {
                        UseDataServiceCollection = this.UseDataServiceCollection,
                        UseAsyncDataServiceCollection = this.UseAsyncDataServiceCollection,
                        TargetLanguage = this.TargetLanguage,
                        EnableNamingAlias = this.EnableNamingAlias,
                        TempFilePath = this.TempFilePath,
                        IgnoreUnexpectedElementsAndAttributes = this.IgnoreUnexpectedElementsAndAttributes,
                        GenerateDynamicPropertiesCollection = this.GenerateDynamicPropertiesCollection,
                        DynamicPropertiesCollectionName = this.DynamicPropertiesCollectionName,
                        GenerateOperationInputWrapperClasses = this.GenerateOperationInputWrapperClasses,
                        ExcludedOperationImportsNames = this.ExcludedOperationImportsNames
                    };
                }
                else
                {
                    this.ApplyParametersFromCommandLine();
                    if (string.IsNullOrEmpty(metadataDocumentUri))
                    {
                        this.ApplyParametersFromConfigurationClass();
                    }

                    context = new CodeGenerationContext(new Uri(this.MetadataDocumentUri, UriKind.Absolute), this.NamespacePrefix)
                    {
                        UseDataServiceCollection = this.UseDataServiceCollection,
                        UseAsyncDataServiceCollection = this.UseAsyncDataServiceCollection,
                        TargetLanguage = this.TargetLanguage,
                        EnableNamingAlias = this.EnableNamingAlias,
                        TempFilePath = this.TempFilePath,
                        IgnoreUnexpectedElementsAndAttributes = this.IgnoreUnexpectedElementsAndAttributes,
                        GenerateDynamicPropertiesCollection = this.GenerateDynamicPropertiesCollection,
                        DynamicPropertiesCollectionName = this.DynamicPropertiesCollectionName,
                        GenerateOperationInputWrapperClasses = this.GenerateOperationInputWrapperClasses,
                        ExcludedOperationImportsNames = this.ExcludedOperationImportsNames
                    };
                }

                if (this.GetReferencedModelReaderFunc != null)
                {
                    context.GetReferencedModelReaderFunc = this.GetReferencedModelReaderFunc;
                }

                ODataClientTemplate template;
                switch (this.TargetLanguage)
                {
                    case LanguageOption.CSharp:
                        template = new ODataClientCSharpTemplate(context);
                        break;
                    case LanguageOption.VB:
                        template = new ODataClientVBTemplate(context);
                        break;

                    default:
                        throw new NotSupportedException($"Code gen for the target language '{this.TargetLanguage.ToString()}' is not supported.");
                }

                this.Write(this.ToStringHelper.ToStringWithCulture(template.TransformText()));

                foreach (string warning in context.Warnings)
                {
                    this.Warning(warning);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }

            return this.GenerationEnvironment.ToString();
        }
        private global::Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost hostValue;
        /// <summary>
        /// The current host for the text templating engine
        /// </summary>
        public virtual global::Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost Host
        {
            get => this.hostValue;
            set => this.hostValue = value;
        }

public static class Configuration
{
	// The URI of the metadata document. The value must be set to a valid service document URI or a local file path 
    // eg : "http://services.odata.org/V4/OData/OData.svc/", "File:///C:/Odata.edmx", or @"C:\Odata.edmx"
    // ### Notice ### If the OData service requires authentication for accessing the metadata document, the value of
    // MetadataDocumentUri has to be set to a local file path, or the client code generation process will fail.
	public const string MetadataDocumentUri = "";

	// The use of DataServiceCollection enables entity and property tracking. The value must be set to true or false.
	public const bool UseDataServiceCollection = true;
	// Modifies the entity and property tracking to support synchronous notification to async operations. The value must be set to true or false.
	public const bool UseAsyncDataServiceCollection = false;

	// The namespace of the client code generated. It replaces the original namespace in the metadata document, 
    // unless the model has several namespaces.
	public const string NamespacePrefix = "$rootnamespace$";

	// The target language of the generated client code. The value must be set to "CSharp" or "VB".
	public const string TargetLanguage = "OutputLanguage";
	
	// The path for the temporary file where the metadata xml document can be stored. Use this if your metadata is too big to be stored in a string literal. Ensure that you have write permission for this path.
	// For example - "C:\\temp\\Test.xml"	
	public const string TempFilePath = "";

	// This flag indicates whether to enable naming alias. The value must be set to true or false.
	public const bool EnableNamingAlias = true;

	// This flag indicates whether to ignore unexpected elements and attributes in the metadata document and generate
	// the client code if any. The value must be set to true or false.
	public const bool IgnoreUnexpectedElementsAndAttributes = true;

    // This flag indicates whether to generate an additional Dictionary<string, object> property
    // to store dynamic properties in open types.  The value must be set to true or false.
    public const bool GenerateDynamicPropertiesCollection = true;

    // This defines the name of Dictionary<string, object> properties
    // that store dynamic properties in open types. This property is only applicable if
    // GenerateDynamicPropertiesCollection is set to true. This value must be
    // a valid identifier name.
    public const string DynamicPropertiesCollectionName = "DynamicProperties";

    // This flag indicates whether to generate wrapper classes around the input arguments for actions so they can be passed as a single entity
    // this was the default behavior in SOAP and WCF services client generation, but is still relevant today as it allows advanced user interface
    // option such as binding these classes directly to the UI as simple view models, this feature is most powerful when combined with `UseDataServiceCollection`
    public const bool GenerateOperationInputWrapperClasses = false;

    // The string for the comma separated OperationImports (ActionImports and FunctionImports) names in metadata to exclude from generated code. 
    public const string ExcludedOperationImportsNames = "";

    // 
    public const string T4Version = "2.6.0";
}

public static class Customization
{
	/// <summary>
	/// Changes the text to use upper camel case, which upper case for the first character.
	/// </summary>
	/// <param name="text">Text to convert.</param>
	/// <returns>The converted text in upper camel case</returns>
	internal static string CustomizeNaming(string text)
	{
		if (string.IsNullOrEmpty(text))
		{
			return text;
		}

		if (text.Length == 1)
		{
			return Char.ToUpperInvariant(text[0]).ToString(CultureInfo.InvariantCulture);
		}

		return Char.ToUpperInvariant(text[0]) + text.Substring(1);
	}

	/// <summary>
	/// Changes the namespace to use upper camel case, which upper case for the first character of all segments.
	/// </summary>
	/// <param name="fullNamespace">Namespace to convert.</param>
	/// <returns>The converted namespace in upper camel case</returns>
	internal static string CustomizeNamespace(string fullNamespace)
	{
		if (string.IsNullOrEmpty(fullNamespace))
		{
			return fullNamespace;
		}

		string[] segs = fullNamespace.Split('.');
		string upperNamespace = string.Empty;
		int n = segs.Length;
		for (int i = 0; i < n; ++i)
		{
			upperNamespace += Customization.CustomizeNaming(segs[i]);
			upperNamespace += (i == n - 1 ? string.Empty : ".");
		}

		return upperNamespace;
	}
}


/// <summary>
/// The string for the edmx content.
/// </summary>
public string Edmx
{
    get;
    set;
}

/// <summary>
/// The Uri string to the metadata document.
/// </summary>
public string MetadataDocumentUri
{
    get => this.metadataDocumentUri;

    set
    {
        value = Uri.UnescapeDataString(value);
        Uri uri;
        if (!Uri.TryCreate(value, UriKind.Absolute, out uri))
        {
            // ********************************************************************************************************
            // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
            // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
            // value then hit Ctrl-S to save the .tt file to refresh the code generation.
            // ********************************************************************************************************
            throw new ArgumentException(string.Format("The value \"{0}\" is not a valid MetadataDocumentUri because is it not a valid absolute Uri. The MetadataDocumentUri must be set to an absolute Uri referencing the $metadata endpoint of an OData service.", value));
        }

        if (uri.Scheme == "http" || uri.Scheme == "https")
        {
            value = uri.Scheme + "://" + uri.Authority + uri.AbsolutePath;
            value = value.TrimEnd('/');
            if (!value.EndsWith("$metadata"))
            {
                value += "/$metadata";
            }
        }

        this.metadataDocumentUri = value;
    }
}

private string metadataDocumentUri;

/// <summary>
/// The Func to get referenced model's XmlReader. Must have value when the this.Edmx xml or this.metadataDocumentUri's model has referneced model.
/// </summary>
public Func<Uri,XmlReader> GetReferencedModelReaderFunc
{
    get;
    set;
}

/// <summary>
/// The NamespacePrefix is used as the only namespace for types in the same namespace as the default container,
/// and as a prefix for the namespace from the model for everything else. If this argument is null, the
/// namespaces from the model are used for all types.
/// </summary>
public string NamespacePrefix
{
    get => this.namespacePrefix;

    set => this.namespacePrefix = string.IsNullOrWhiteSpace(value) ? null : value;
}

private string namespacePrefix;

/// <summary>
/// true to use DataServiceCollection in the generated code, false otherwise.
/// </summary>
public bool UseDataServiceCollection
{
    get;
    set;
}
/// <summary>
/// true to change the INotifyPropertyChanged Implementation to support async operations with synchronous event callbacks
/// </summary>
/// <remarks>This should only be set to true if the <see cref="UseDataServiceCollection"/> is also true.</remarks>
public bool UseAsyncDataServiceCollection
{
    get;
    set;
}

/// <summary>
/// Specifies which specific .Net Framework language the generated code will target.
/// </summary>
public LanguageOption TargetLanguage
{
    get;
    set;
}

/// <summary>
/// true to use Upper camel case for all class and property names, false otherwise.
/// </summary>
public bool EnableNamingAlias
{
    get;
    set;
}

/// <summary>
/// The path for the temporary file where the metadata xml document can be stored.
/// </summary>
public string TempFilePath
{
    get;
    set;
}

/// <summary>
/// true to ignore unknown elements or attributes in metadata, false otherwise.
/// </summary>
public bool IgnoreUnexpectedElementsAndAttributes
{
    get;
    set;
}

/// <summary>
/// true to generate open type property dirctionary, false otherwise.
/// </summary>
public bool GenerateDynamicPropertiesCollection
{
    get;
    set;
}

/// <summary>
/// Name of the OpenType dictionary property
/// </summary>
public string DynamicPropertiesCollectionName
{
    get;
    set;
}

/// <summary>
/// Generate classes to wrap action input arguments so they can be passed as a single entity, and these classes can then be used as simple view models that can be bound to user interfaces
/// </summary>
public bool GenerateOperationInputWrapperClasses
{
    get;
    set;
}

/// <summary>
/// The string for the comma separated OperationImports (ActionImports and FunctionImports) names in metadata to exclude from generated code.
/// </summary>
public string ExcludedOperationImportsNames
{
    get => this.excludedOperationImportsNames;

    set => this.excludedOperationImportsNames = string.IsNullOrWhiteSpace(value) ? null : value;
}

private string excludedOperationImportsNames;

/// <summary>
/// Generate code targeting a specific .Net Framework language.
/// </summary>
public enum LanguageOption
{
    /// <summary>Generate code for C# language.</summary>
    CSharp = 0,

    /// <summary>Generate code for Visual Basic language.</summary>
    VB = 1,
}

/// <summary>
/// Set the UseDataServiceCollection property with the given value.
/// </summary>
/// <param name="stringValue">The value to set.</param>
public void ValidateAndSetUseDataServiceCollectionFromString(string stringValue)
{
    bool boolValue;
    if (!bool.TryParse(stringValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException($"The value \"{stringValue}\" cannot be assigned to the UseDataServiceCollection parameter because it is not a valid boolean value.");
    }

    this.UseDataServiceCollection = boolValue;
}
/// <summary>
/// Set the UseAsyncDataServiceCollection property with the given value.
/// </summary>
/// <param name="stringValue">The value to set.</param>
public void ValidateAndSetUseAsyncDataServiceCollectionFromString(string stringValue)
{
    bool boolValue;
    if (!bool.TryParse(stringValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException($"The value \"{stringValue}\" cannot be assigned to the UseAsyncDataServiceCollection parameter because it is not a valid boolean value.");
    }

    this.UseAsyncDataServiceCollection = boolValue;
}

/// <summary>
/// Tries to set the TargetLanguage property with the given value.
/// </summary>
/// <param name="stringValue">The value to set.</param>
public void ValidateAndSetTargetLanguageFromString(string stringValue)
{
    LanguageOption option;
    if (!Enum.TryParse(stringValue, true, out option))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException($"The value \"{stringValue}\" cannot be assigned to the TargetLanguage parameter because it is not a valid LanguageOption. The supported LanguageOptions are \"CSharp\" and \"VB\".");
    }

    this.TargetLanguage = option;
}

/// <summary>
/// Set the EnableNamingAlias property with the given value.
/// </summary>
/// <param name="stringValue">The value to set.</param>
public void ValidateAndSetEnableNamingAliasFromString(string stringValue)
{
    bool boolValue;
    if (!bool.TryParse(stringValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException($"The value \"{stringValue}\" cannot be assigned to the EnableNamingAlias parameter because it is not a valid boolean value.");
    }

    this.EnableNamingAlias = boolValue;
}

/// <summary>
/// Set the IgnoreUnexpectedElementsAndAttributes property with the given value.
/// </summary>
/// <param name="stringValue">The value to set.</param>
public void ValidateAndSetIgnoreUnexpectedElementsAndAttributesFromString(string stringValue)
{
    bool boolValue;
    if (!bool.TryParse(stringValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException($"The value \"{stringValue}\" cannot be assigned to the IgnoreUnexpectedElementsAndAttributes parameter because it is not a valid boolean value.");
    }

    this.IgnoreUnexpectedElementsAndAttributes = boolValue;
}

/// <summary>
/// Set the GenerateDynamicPropertiesCollection property with the given value.
/// </summary>
/// <param name="stringValue">The value to set.</param>
public void ValidateAndSetGenerateDynamicPropertiesCollectionFromString(string stringValue)
{
    bool boolValue;
    if (!bool.TryParse(stringValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format("The value \"{0}\" cannot be assigned to the GenerateDynamicPropertiesCollection parameter because it is not a valid boolean value.", stringValue));
    }

    this.GenerateDynamicPropertiesCollection = boolValue;
}

/// <summary>
/// Set the GenerateOperationInputWrapperClasses property with the given value.
/// </summary>
/// <param name="stringValue">The value to set.</param>
public void ValidateAndSetGenerateOperationInputWrapperClassesFromString(string stringValue)
{
    bool boolValue;
    if (!bool.TryParse(stringValue, out boolValue))
    {
        // ********************************************************************************************************
        // To fix this error, if the current text transformation is run by the TextTemplatingFileGenerator
        // custom tool inside Visual Studio, update the .odata.config file in the project with a valid parameter
        // value then hit Ctrl-S to save the .tt file to refresh the code generation.
        // ********************************************************************************************************
        throw new ArgumentException(string.Format("The value \"{0}\" cannot be assigned to the GenerateOperationInputWrapperClasses parameter because it is not a valid boolean value.", stringValue));
    }

    this.GenerateOperationInputWrapperClasses = boolValue;
}

/// <summary>
/// Reads the parameter values from the Configuration class and applies them.
/// </summary>
private void ApplyParametersFromConfigurationClass()
{
    this.MetadataDocumentUri = Configuration.MetadataDocumentUri;
    this.NamespacePrefix = Configuration.NamespacePrefix;
    this.UseDataServiceCollection = Configuration.UseDataServiceCollection;
    this.UseAsyncDataServiceCollection = Configuration.UseAsyncDataServiceCollection;
    this.ValidateAndSetTargetLanguageFromString(Configuration.TargetLanguage);
    this.EnableNamingAlias = Configuration.EnableNamingAlias;
    this.TempFilePath = Configuration.TempFilePath;
    this.IgnoreUnexpectedElementsAndAttributes = Configuration.IgnoreUnexpectedElementsAndAttributes;
    this.GenerateDynamicPropertiesCollection = Configuration.GenerateDynamicPropertiesCollection;
    this.DynamicPropertiesCollectionName = Configuration.DynamicPropertiesCollectionName;
    this.GenerateOperationInputWrapperClasses = Configuration.GenerateOperationInputWrapperClasses;
    this.ExcludedOperationImportsNames = Configuration.ExcludedOperationImportsNames;
}

/// <summary>
/// Reads the parameter values from the command line (TextTransform.exe) and applies them.
/// </summary>
private void ApplyParametersFromCommandLine()
{
    if (this.Host == null)
    {
        return;
    }

    string metadataDocumentUri = this.Host.ResolveParameterValue("notempty", "notempty", "MetadataDocumentUri");
    if (!string.IsNullOrEmpty(metadataDocumentUri))
    {
        this.MetadataDocumentUri = metadataDocumentUri;
    }

    string namespacePrefix = this.Host.ResolveParameterValue("notempty", "notempty", "NamespacePrefix");
    if (!string.IsNullOrEmpty(namespacePrefix))
    {
        this.NamespacePrefix = namespacePrefix;
    }

    string useDataServiceCollection = this.Host.ResolveParameterValue("notempty", "notempty", "UseDataServiceCollection");
    if (!string.IsNullOrEmpty(useDataServiceCollection))
    {
        this.ValidateAndSetUseDataServiceCollectionFromString(useDataServiceCollection);
    }

    string useAsyncDataServiceCollection = this.Host.ResolveParameterValue("notempty", "notempty", "UseAsyncDataServiceCollection");
    if (!string.IsNullOrEmpty(useAsyncDataServiceCollection))
    {
        this.ValidateAndSetUseAsyncDataServiceCollectionFromString(useAsyncDataServiceCollection);
    }

    string targetLanguage = this.Host.ResolveParameterValue("notempty", "notempty", "TargetLanguage");
    if (!string.IsNullOrEmpty(targetLanguage))
    {
        this.ValidateAndSetTargetLanguageFromString(targetLanguage);
    }

    string enableNamingAlias = this.Host.ResolveParameterValue("notempty", "notempty", "EnableNamingAlias");
    if (!string.IsNullOrEmpty(enableNamingAlias))
    {
        this.ValidateAndSetEnableNamingAliasFromString(enableNamingAlias);
    }

    string ignoreUnexpectedElementsAndAttributes = this.Host.ResolveParameterValue("notempty", "notempty", "IgnoreUnexpectedElementsAndAttributes");
    if (!string.IsNullOrEmpty(ignoreUnexpectedElementsAndAttributes))
    {
        this.ValidateAndSetIgnoreUnexpectedElementsAndAttributesFromString(ignoreUnexpectedElementsAndAttributes);
    }

    string generateDynamicPropertiesCollection = this.Host.ResolveParameterValue("notempty", "notempty", "GenerateDynamicPropertiesCollection");
    if (!string.IsNullOrEmpty(generateDynamicPropertiesCollection))
    {
        this.ValidateAndSetGenerateDynamicPropertiesCollectionFromString(generateDynamicPropertiesCollection);
    }

    string dynamicPropertiesCollectionName = this.Host.ResolveParameterValue("notempty", "notempty", "DynamicPropertiesCollectionName");
    if (!string.IsNullOrEmpty(dynamicPropertiesCollectionName))
    {
        this.DynamicPropertiesCollectionName = dynamicPropertiesCollectionName;
    }

    string GenerateOperationInputWrapperClasses = this.Host.ResolveParameterValue("notempty", "notempty", "GenerateOperationInputWrapperClasses");
    if (!string.IsNullOrEmpty(GenerateOperationInputWrapperClasses))
    {
        this.ValidateAndSetGenerateOperationInputWrapperClassesFromString(GenerateOperationInputWrapperClasses);
    }

    string excludedOperationImportsNames = this.Host.ResolveParameterValue("notempty", "notempty", "ExcludedOperationImportsNames");
    if (!string.IsNullOrEmpty(excludedOperationImportsNames))
    {
        this.ExcludedOperationImportsNames = excludedOperationImportsNames;
    }
}

/// <summary>
/// Context object to provide the model and configuration info to the code generator.
/// </summary>
public class CodeGenerationContext
{
    /// <summary>
    /// The namespace of the term to use when building annotations for indicating the conventions used.
    /// </summary>
    private const string ConventionTermNamespace = "Com.Microsoft.OData.Service.Conventions.V1";

    /// <summary>
    /// The name of the term to use when building annotations for indicating the conventions used.
    /// </summary>
    private const string ConventionTermName = "UrlConventions";

    /// <summary>
    /// The string value for indicating that the key-as-segment convention is being used in annotations and headers.
    /// </summary>
    private const string KeyAsSegmentConventionName = "KeyAsSegment";

    /// <summary>
    /// The XElement for the edmx
    /// </summary>
    private readonly XElement edmx;

    /// <summary>
    /// The namespacePrefix is used as the only namespace in generated code when there's only one schema in edm model,
    /// and as a prefix for the namespace from the model with multiple schemas. If this argument is null, the
    /// namespaces from the model are used for all types.
    /// </summary>
    private readonly string namespacePrefix;

    /// <summary>
    /// The EdmModel to generate code for.
    /// </summary>
    private IEdmModel edmModel;

    /// <summary>
    /// The array of namespaces in the current edm model.
    /// </summary>
    private string[] namespacesInModel;

    /// <summary>
    /// The array of warnings occured when parsing edm model.
    /// </summary>
    private string[] warnings;

    /// <summary>
    /// true if the model contains any structural type with inheritance, false otherwise.
    /// </summary>
    private bool? modelHasInheritance;

    /// <summary>
    /// If the namespacePrefix is not null, this contains the mapping of namespaces in the model to the corresponding prefixed namespaces.
    /// Otherwise this is an empty dictionary.
    /// </summary>
    private Dictionary<string, string> namespaceMap;

    /// <summary>
    /// Maps the element type of a navigation source to the navigation source.
    /// </summary>
    private Dictionary<IEdmEntityType, List<IEdmNavigationSource>> elementTypeToNavigationSourceMap;

    /// <summary>
    /// HashSet contains the pair of Names and Namespaces of EntityContainers using KeyAsSegment url convention
    /// </summary>
    private HashSet<string> keyAsSegmentContainers;

    /// <summary>
    /// Constructs an instance of <see cref="CodeGenerationContext"/>.
    /// </summary>
    /// <param name="metadataUri">The Uri to the metadata document. The supported scheme are File, http and https.</param>
    public CodeGenerationContext(Uri metadataUri, string namespacePrefix)
        : this(GetEdmxStringFromMetadataPath(metadataUri), namespacePrefix)
    {
    }

    /// <summary>
    /// Constructs an instance of <see cref="CodeGenerationContext"/>.
    /// </summary>
    /// <param name="edmx">The string for the edmx.</param>
    /// <param name="namespacePrefix">The namespacePrefix is used as the only namespace in generated code
    /// when there's only one schema in edm model, and as a prefix for the namespace from the model with multiple
    /// schemas. If this argument is null, the namespaces from the model are used for all types.</param>
    public CodeGenerationContext(string edmx, string namespacePrefix)
    {
        this.edmx = XElement.Parse(edmx);
        this.namespacePrefix = namespacePrefix;
    }

    /// <summary>
    /// The EdmModel to generate code for.
    /// </summary>
    public XElement Edmx => this.edmx;

    /// <summary>
    /// The EdmModel to generate code for.
    /// </summary>
    public IEdmModel EdmModel
    {
        get
        {
            if (this.edmModel == null)
            {
                Debug.Assert(this.edmx != null, "this.edmx != null");

                IEnumerable<Microsoft.OData.Edm.Validation.EdmError> errors;
                CsdlReaderSettings edmxReaderSettings = new CsdlReaderSettings
                {
                    GetReferencedModelReaderFunc = this.GetReferencedModelReaderFuncWrapper,
                    IgnoreUnexpectedAttributesAndElements = this.IgnoreUnexpectedElementsAndAttributes
                };
                if (!CsdlReader.TryParse(this.edmx.CreateReader(ReaderOptions.None), Enumerable.Empty<IEdmModel>(), edmxReaderSettings, out this.edmModel, out errors))
                {
                    Debug.Assert(errors != null, "errors != null");
                    throw new InvalidOperationException(errors.FirstOrDefault().ErrorMessage);
                }
                else if (this.IgnoreUnexpectedElementsAndAttributes)
                {
                    if (errors != null && errors.Any())
                    {
                        this.warnings = errors.Select(e => e.ErrorMessage).ToArray();
                    }
                }
            }

            return this.edmModel;
        }
    }

    /// <summary>
    /// The func for user code to overwrite and provide referenced model's XmlReader.
    /// </summary>
    public Func<Uri,XmlReader> GetReferencedModelReaderFunc
    {
        get => getReferencedModelReaderFunc;
        set => this.getReferencedModelReaderFunc = value;
    }

    /// <summary>
    /// Basic setting for XmlReader.
    /// </summary>
    private static readonly XmlReaderSettings settings = new XmlReaderSettings() { IgnoreWhitespace = true };

    /// <summary>
    /// The func for user code to overwrite and provide referenced model's XmlReader.
    /// </summary>
    private Func<Uri, XmlReader> getReferencedModelReaderFunc = uri => XmlReader.Create(GetEdmxStreamFromUri(uri), settings);

    /// <summary>
    /// The Wrapper func for user code to overwrite and provide referenced model's stream.
    /// </summary>
    public Func<Uri, XmlReader> GetReferencedModelReaderFuncWrapper
    {
        get
        {
            return (uri) =>
            {
                using (XmlReader reader = GetReferencedModelReaderFunc(uri))
                {
                    if (reader == null)
                    {
                        return null;
                    }

                    XElement element = XElement.Load(reader);
                    if (this.ReferencesMap == null)
                    {
                        this.ReferencesMap = new Dictionary<Uri, XElement>();
                    }

                    this.ReferencesMap.Add(uri, element);
                    return element.CreateReader(ReaderOptions.None);
                }
            };
        }
    }

    /// <summary>
    /// Dictionary that stores uri and referenced xml mapping.
    /// </summary>
    public Dictionary<Uri, XElement> ReferencesMap
    {
        get;
        set;
    }

    /// <summary>
    /// The array of namespaces in the current edm model.
    /// </summary>
    public string[] NamespacesInModel
    {
        get
        {
            if (this.namespacesInModel == null)
            {
                Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
                this.namespacesInModel = GetElementsFromModelTree(this.EdmModel, (m) => m.SchemaElements.Select(e => e.Namespace)).Distinct().ToArray();
            }

            return this.namespacesInModel;
        }
    }

    /// <summary>
    /// The array of warnings occured when parsing edm model.
    /// </summary>
    public string[] Warnings => this.warnings ?? (this.warnings = new string[] {});

    /// <summary>
    /// true if the model contains any structural type with inheritance, false otherwise.
    /// </summary>
    public bool ModelHasInheritance
    {
        get
        {
            if (!this.modelHasInheritance.HasValue)
            {
                Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
                this.modelHasInheritance = this.EdmModel.SchemaElementsAcrossModels()
                            .OfType<IEdmStructuredType>().Any(t => !t.FullTypeName().StartsWith("Org.OData.Authorization.V1") && !t.FullTypeName().StartsWith("Org.OData.Core.V1") && t.BaseType != null);
            }

            return this.modelHasInheritance.Value;
        }
    }

    /// <summary>
    /// true if we need to generate the ResolveNameFromType method, false otherwise.
    /// </summary>
    public bool NeedResolveNameFromType => this.ModelHasInheritance || this.NamespaceMap.Count > 0 || this.EnableNamingAlias;

    /// <summary>
    /// true if we need to generate the ResolveTypeFromName method, false otherwise.
    /// </summary>
    public bool NeedResolveTypeFromName => this.NamespaceMap.Count > 0 || this.EnableNamingAlias;

    /// <summary>
    /// If the namespacePrefix is not null, this contains the mapping of namespaces in the model to the corresponding prefixed namespaces.
    /// Otherwise this is an empty dictionary.
    /// </summary>
    public Dictionary<string, string> NamespaceMap
    {
        get
        {
            if (this.namespaceMap == null)
            {
                if (!string.IsNullOrEmpty(this.namespacePrefix))
                {
                    if (this.NamespacesInModel.Count() == 1)
                    {
                        IEdmEntityContainer container = this.EdmModel.EntityContainer;
                        string containerNamespace = container?.Namespace;
                        this.namespaceMap = this.NamespacesInModel
                            .Distinct()
                            .ToDictionary(
                                ns => ns,
                                ns => ns == containerNamespace ?
                                    this.namespacePrefix :
                                    this.namespacePrefix + "." + (this.EnableNamingAlias ? Customization.CustomizeNamespace(ns) : ns));
                    }
                    else
                    {
                        this.namespaceMap = this.NamespacesInModel
                            .Distinct()
                            .ToDictionary(
                                ns => ns,
                                ns => this.namespacePrefix + "." + (this.EnableNamingAlias ? Customization.CustomizeNamespace(ns) : ns));
                    }
                }
                else if (this.EnableNamingAlias)
                {
                    this.namespaceMap = this.NamespacesInModel
                            .Distinct()
                            .ToDictionary(
                                ns => ns,
                                ns => Customization.CustomizeNamespace(ns));
                }
                else
                {
                    this.namespaceMap = new Dictionary<string, string>();
                }
            }

            return this.namespaceMap;
        }
    }

    /// <summary>
    /// true to use DataServiceCollection in the generated code, false otherwise.
    /// </summary>
    public bool UseDataServiceCollection
    {
        get;
        set;
    }

    /// <summary>
    /// true to change the INotifyPropertyChanged Implementation to support async operations with synchronous event callbacks
    /// </summary>
    /// <remarks>This should only be set to true if the <see cref="UseDataServiceCollection"/> is also true.</remarks>
    public bool UseAsyncDataServiceCollection
    {
        get;
        set;
    }

    /// <summary>
    /// Specifies which specific .Net Framework language the generated code will target.
    /// </summary>
    public LanguageOption TargetLanguage
    {
        get;
        set;
    }
    
    /// <summary>
    /// The path for the temporary file where the metadata xml document can be stored.
    /// </summary>
    public string TempFilePath
    {
        get;
        set;
    }
    /// <summary>
    /// true to use Upper camel case for all class and property names, false otherwise.
    /// </summary>
    public bool EnableNamingAlias
    {
        get;
        set;
    }

    /// <summary>
    /// true to ignore unknown elements or attributes in metadata, false otherwise.
    /// </summary>
    public bool IgnoreUnexpectedElementsAndAttributes
    {
        get;
        set;
    }

    /// <summary>
    /// true to generate open type property dictionary, false otherwise.
    /// </summary>
    public bool GenerateDynamicPropertiesCollection
    {
        get;
        set;
    }

    /// <summary>
    /// Name of the OpenType dictionary property
    /// </summary>
    public string DynamicPropertiesCollectionName
    {
        get;
        set;
    }

    /// <summary>
    /// Generate classes to wrap opertaion input arguments so they can be passed as a single entity, and these classes can then be used as simple view models that can be bound to user interfaces
    /// </summary>
    public bool GenerateOperationInputWrapperClasses
    {
        get;
        set;
    }

    /// <summary>
    /// The string for the comma separated OperationImports (ActionImports and FunctionImports) names in metadata to exclude from generated code.
    /// </summary>
    public string ExcludedOperationImportsNames
    {
        get => this.excludedOperationImportsNames;

        set => this.excludedOperationImportsNames = string.IsNullOrWhiteSpace(value) ? null : value;
    }

    private string excludedOperationImportsNames;

    /// <summary>
    /// Maps the element type of an entity set to the entity set.
    /// </summary>
    public Dictionary<IEdmEntityType, List<IEdmNavigationSource>> ElementTypeToNavigationSourceMap => this.elementTypeToNavigationSourceMap ?? (this.elementTypeToNavigationSourceMap = new Dictionary<IEdmEntityType, List<IEdmNavigationSource>>(EqualityComparer<IEdmEntityType>.Default));

    /// <summary>
    /// true if this EntityContainer need to set the UrlConvention to KeyAsSegment, false otherwise.
    /// </summary>
    public bool UseKeyAsSegmentUrlConvention(IEdmEntityContainer currentContainer)
    {
        if (this.keyAsSegmentContainers == null)
        {
            this.keyAsSegmentContainers = new HashSet<string>();
            Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
            IEnumerable<IEdmVocabularyAnnotation> annotations = this.EdmModel.VocabularyAnnotations;
            foreach(IEdmVocabularyAnnotation valueAnnotation in annotations)
            {
                IEdmEntityContainer container = valueAnnotation.Target as IEdmEntityContainer;
                IEdmTerm valueTerm = valueAnnotation.Term;
                if (container != null && valueTerm != null && valueAnnotation.Value is IEdmStringConstantExpression expression)
                {
                    if (valueTerm.Namespace == ConventionTermNamespace &&
                        valueTerm.Name == ConventionTermName &&
                        expression.Value == KeyAsSegmentConventionName)
                    {
                        this.keyAsSegmentContainers.Add(container.FullName());
                    }
                }
            }
        }

        return this.keyAsSegmentContainers.Contains(currentContainer.FullName());
    }

    /// <summary>
    /// Gets the enumeration of schema elements with the given namespace.
    /// </summary>
    /// <param name="ns">The namespace of the schema elements to get.</param>
    /// <returns>The enumeration of schema elements with the given namespace.</returns>
    public IEnumerable<IEdmSchemaElement> GetSchemaElements(string ns)
    {
        Debug.Assert(ns != null, "ns != null");
        Debug.Assert(this.EdmModel != null, "this.EdmModel != null");
        return GetElementsFromModelTree(this.EdmModel, m => m.SchemaElements.Where(e => e.Namespace == ns));
    }

    /// <summary>
    /// Gets the namespace qualified name for the given <paramref name="schemaElement"/> with the namespace prefix applied if this.NamespacePrefix is specified.
    /// </summary>
    /// <param name="schemaElement">The schema element to get the full name for.</param>
    /// <param name="schemaElementFixedName">The fixed name of this schemaElement.</param>
    /// <param name="template">The current code generate template.</param>
    /// <returns>The namespace qualified name for the given <paramref name="schemaElement"/> with the namespace prefix applied if this.NamespacePrefix is specified.</returns>
    public string GetPrefixedFullName(IEdmSchemaElement schemaElement, string schemaElementFixedName, ODataClientTemplate template, bool needGlobalPrefix = true)
    {
        if (schemaElement == null)
        {
            return null;
        }

        return this.GetPrefixedNamespace(schemaElement.Namespace, template, true, needGlobalPrefix) + "." + schemaElementFixedName;
    }

    /// <summary>
    /// Gets the prefixed namespace for the given <paramref name="ns"/>.
    /// </summary>
    /// <param name="ns">The namespace without the prefix.</param>
    /// <param name="template">The current code generate template.</param>
    /// <param name="needFix">The flag indicates whether the namespace need to be fixed now.</param>
    /// <param name="needGlobalPrefix">The flag indicates whether the namespace need to be added by gloabal prefix.</param>
    /// <returns>The prefixed namespace for the given <paramref name="ns"/>.</returns>
    public string GetPrefixedNamespace(string ns, ODataClientTemplate template, bool needFix, bool needGlobalPrefix)
    {
        if (ns == null)
        {
            return null;
        }

        if (!this.NamespaceMap.TryGetValue(ns, out var prefixedNamespace))
        {
            prefixedNamespace = ns;
        }

        if (needFix)
        {
            string[] segments = prefixedNamespace.Split('.');
            prefixedNamespace = string.Empty;
            int n = segments.Length;
            for (int i = 0; i < n; ++i)
            {
                if (template.LanguageKeywords.Contains(segments[i]))
                {
                    prefixedNamespace += string.Format(template.FixPattern, segments[i]);
                }
                else
                {
                    prefixedNamespace += segments[i];
                }

                prefixedNamespace += (i == n - 1 ? string.Empty : ".");
            }
        }

        if (needGlobalPrefix)
        {
            prefixedNamespace = template.GlobalPrefix + prefixedNamespace;
        }
        
        return prefixedNamespace;
    }

    /// <summary>
    /// Reads the edmx string from a file path or a http/https path.
    /// </summary>
    /// <param name="metadataUri">The Uri to the metadata document. The supported scheme are File, http and https.</param>
    private static string GetEdmxStringFromMetadataPath(Uri metadataUri)
    {
        string content = null;
        using (StreamReader streamReader = new StreamReader(GetEdmxStreamFromUri(metadataUri)))
        {
            content = streamReader.ReadToEnd();
        }

        return content;
    }

    /// <summary>
    /// Get the metadata stream from a file path or a http/https path.
    /// </summary>
    /// <param name="metadataUri">The Uri to the stream. The supported scheme are File, http and https.</param>
    private static Stream GetEdmxStreamFromUri(Uri metadataUri)
    {
        Debug.Assert(metadataUri != null, "metadataUri != null");
        Stream metadataStream = null;
        if (metadataUri.Scheme == "file")
        {
            metadataStream = new FileStream(Uri.UnescapeDataString(metadataUri.AbsolutePath), FileMode.Open, FileAccess.Read);
        }
        else if (metadataUri.Scheme == "http" || metadataUri.Scheme == "https")
        {
            try
            {
                HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(metadataUri);
                WebResponse webResponse = webRequest.GetResponse();
                metadataStream = webResponse.GetResponseStream();
            }
            catch (WebException e)
            {
                if (e.Response is HttpWebResponse webResponse && webResponse.StatusCode == HttpStatusCode.Unauthorized)
                {
                    throw new WebException("Failed to access the metadata document. The OData service requires authentication for accessing it. Please download the metadata, store it into a local file, and set the value of “MetadataDocumentUri” in the .odata.config file to the file path. After that, run custom tool again to generate the OData Client code.");
                }
                else
                {
                    throw e;
                }
            }
        }
        else
        {
            throw new ArgumentException("Only file, http, https schemes are supported for paths to metadata source locations.");
        }

        return metadataStream;
    }

    private static IEnumerable<T> GetElementsFromModelTree<T>(IEdmModel mainModel, Func<IEdmModel, IEnumerable<T>> getElementFromOneModelFunc)
    {
        List<T> ret = new List<T>();
        if(mainModel is EdmCoreModel || mainModel.FindDeclaredTerm(CoreVocabularyConstants.OptimisticConcurrency) != null)
        {
            return ret;
        }

        ret.AddRange(getElementFromOneModelFunc(mainModel));
        foreach (var tmp in mainModel.ReferencedModels)
        {
            if (tmp is EdmCoreModel ||
                tmp.FindDeclaredTerm(CoreVocabularyConstants.OptimisticConcurrency) != null ||
                tmp.FindDeclaredTerm(CapabilitiesVocabularyConstants.ChangeTracking) != null ||
                tmp.FindDeclaredTerm(AlternateKeysVocabularyConstants.AlternateKeys) != null ||
                tmp.FindDeclaredTerm("Org.OData.Authorization.V1.Authorizations") != null ||
                tmp.FindDeclaredTerm("Org.OData.Validation.V1.DerivedTypeConstraint") != null ||
                tmp.FindDeclaredTerm("Org.OData.Community.V1.UrlEscapeFunction") != null)
            {
                continue;
            }

            ret.AddRange(getElementFromOneModelFunc(tmp));
        }

        return ret;
    }
}

/// <summary>
/// The template class to generate the OData client code.
/// </summary>
public abstract class ODataClientTemplate : TemplateBase
{
    protected const string T4Version  = Configuration.T4Version;

    /// <summary>
    /// The code generation context.
    /// </summary>
    protected readonly CodeGenerationContext context;

    /// <summary>
    /// The Dictionary to store identifier mappings when there are duplicate names between properties and Entity/Complex types
    /// </summary>
    protected Dictionary<string, string> IdentifierMappings = new Dictionary<string, string>(StringComparer.Ordinal);

    /// <summary>
    /// Creates an instance of the ODataClientTemplate.
    /// </summary>
    /// <param name="context">The code generation context.</param>
    public ODataClientTemplate(CodeGenerationContext context)
    {
        this.context = context;
    }

    internal string SingleSuffix => "Single";
    internal string WrappedCollectionOperationClassSuffix => "_Request";
    internal string WrappedItemOperationClassSuffix => "_ItemRequest";

    #region Get Language specific keyword names.
    internal abstract string GlobalPrefix { get; }
    internal abstract string SystemTypeTypeName { get; }
    internal abstract string AbstractModifier { get; }
    internal abstract string DataServiceActionQueryTypeName { get; }
    internal abstract string DataServiceActionQuerySingleOfTStructureTemplate { get; }
    internal abstract string DataServiceActionQueryOfTStructureTemplate { get; }
    internal abstract string NotifyPropertyChangedModifier { get; }
    internal abstract string ClassInheritMarker { get; }
    internal abstract string ParameterSeparator { get; }
    internal abstract string KeyParameterSeparator { get; }
    internal abstract string KeyDictionaryItemSeparator { get; }
    internal abstract string SystemNullableStructureTemplate { get; }
    internal abstract string ICollectionOfTStructureTemplate { get; }
    internal abstract string DataServiceCollectionStructureTemplate { get; }
    internal abstract string DataServiceQueryStructureTemplate { get; }
    internal abstract string DataServiceQuerySingleStructureTemplate { get; }
    internal abstract string ObservableCollectionStructureTemplate { get; }
    internal abstract string ObjectModelCollectionStructureTemplate { get; }
    internal abstract string DataServiceCollectionConstructorParameters { get; }
    internal abstract string NewModifier { get; }
    internal abstract string GeoTypeInitializePattern { get; }
    internal abstract string Int32TypeName { get; }
    internal abstract string ObjectTypeName { get; }
    internal abstract string StringTypeName { get; }
    internal abstract string BinaryTypeName { get; }
    internal abstract string DecimalTypeName { get; }
    internal abstract string Int16TypeName { get; }
    internal abstract string SingleTypeName { get; }
    internal abstract string BooleanTypeName { get; }
    internal abstract string DoubleTypeName { get; }
    internal abstract string GuidTypeName { get; }
    internal abstract string ByteTypeName { get; }
    internal abstract string Int64TypeName { get; }
    internal abstract string SByteTypeName { get; }
    internal abstract string DataServiceStreamLinkTypeName { get; }
    internal abstract string GeographyTypeName { get; }
    internal abstract string GeographyPointTypeName { get; }
    internal abstract string GeographyLineStringTypeName { get; }
    internal abstract string GeographyPolygonTypeName { get; }
    internal abstract string GeographyCollectionTypeName { get; }
    internal abstract string GeographyMultiPolygonTypeName { get; }
    internal abstract string GeographyMultiLineStringTypeName { get; }
    internal abstract string GeographyMultiPointTypeName { get; }
    internal abstract string GeometryTypeName { get; }
    internal abstract string GeometryPointTypeName { get; }
    internal abstract string GeometryLineStringTypeName { get; }
    internal abstract string GeometryPolygonTypeName { get; }
    internal abstract string GeometryCollectionTypeName { get; }
    internal abstract string GeometryMultiPolygonTypeName { get; }
    internal abstract string GeometryMultiLineStringTypeName { get; }
    internal abstract string GeometryMultiPointTypeName { get; }
    internal abstract string DateTypeName { get; }
    internal abstract string DateTimeOffsetTypeName { get; }
    internal abstract string DurationTypeName { get; }
    internal abstract string TimeOfDayTypeName { get; }
    internal abstract string XmlConvertClassName { get; }
    internal abstract string EnumTypeName { get; }
    internal abstract string DictionaryTypeName { get; }
    internal abstract HashSet<string> LanguageKeywords { get; }
    internal abstract string FixPattern { get; }
    internal abstract string EnumUnderlyingTypeMarker { get; }
    internal abstract string ConstantExpressionConstructorWithType { get; }
    internal abstract string TypeofFormatter { get; }
    internal abstract string UriOperationParameterConstructor { get; }
    internal abstract string UriEntityOperationParameterConstructor { get; }
    internal abstract string BodyOperationParameterConstructor { get; }
    internal abstract string DictionaryConstructor { get; }
    internal abstract string BaseEntityType { get; }
    internal abstract string OverloadsModifier { get; }
    internal abstract string ODataVersion { get; }
    internal abstract string ParameterDeclarationTemplate { get; }
    internal abstract string DictionaryItemConstructor { get; }
    #endregion Get Language specific keyword names.

    #region Language specific write methods.
    internal abstract void WriteFileHeader();
    internal abstract void WriteNamespaceStart(string fullNamespace);
    internal abstract void WriteClassStartForEntityContainer(string originalContainerName, string containerName, string fixedContainerName);
    internal abstract void WriteMethodStartForEntityContainerConstructor(string containerName, string fixedContainerName);
    internal abstract void WriteKeyAsSegmentUrlConvention();
    internal abstract void WriteInitializeResolveName();
    internal abstract void WriteInitializeResolveType();
    internal abstract void WriteClassEndForEntityContainerConstructor();
    internal abstract void WriteMethodStartForResolveTypeFromName();
    internal abstract void WriteResolveNamespace(string typeName, string fullNamespace, string languageDependentNamespace);
    internal abstract void WriteMethodEndForResolveTypeFromName();
    internal abstract void WriteMethodStartForResolveNameFromType(string containerName, string fullNamespace);
    internal abstract void WriteResolveType(string fullNamespace, string languageDependentNamespace);
    internal abstract void WriteMethodEndForResolveNameFromType(bool modelHasInheritance);
    internal abstract void WriteContextEntitySetProperty(string entitySetName, string entitySetFixedName, string originalEntitySetName, string entitySetElementTypeName, bool inContext = true);
    internal abstract void WriteContextSingletonProperty(string singletonName, string singletonFixedName, string originalSingletonName, string singletonElementTypeName, bool inContext = true);
    internal abstract void WriteContextAddToEntitySetMethod(string entitySetName, string originalEntitySetName, string typeName, string parameterName);
    internal abstract void WriteGeneratedEdmModel(string escapedEdmxString);
    internal abstract void WriteClassEndForEntityContainer();
    internal abstract void WriteSummaryCommentForStructuredType(string typeName);
    internal abstract void WriteKeyPropertiesCommentAndAttribute(IEnumerable<string> keyProperties, string keyString);
    internal abstract void WriteEntityTypeAttribute();
    internal abstract void WriteEntitySetAttribute(string entitySetName);
    internal abstract void WriteEntityHasStreamAttribute();
    internal abstract void WriteClassStartForStructuredType(string abstractModifier, string typeName, string originalTypeName, string baseTypeName);
    internal abstract void WriteSummaryCommentForStaticCreateMethod(string typeName);
    internal abstract void WriteParameterCommentForStaticCreateMethod(string parameterName, string propertyName);
    internal abstract void WriteDeclarationStartForStaticCreateMethod(string typeName,string fixedTypeName );
    internal abstract void WriteParameterForStaticCreateMethod(string parameterTypeName, string parameterName, string parameterSeparater);
    internal abstract void WriteDeclarationEndForStaticCreateMethod(string typeName, string instanceName);
    internal abstract void WriteParameterNullCheckForStaticCreateMethod(string parameterName);
    internal abstract void WritePropertyValueAssignmentForStaticCreateMethod(string instanceName, string propertyName, string parameterName);
    internal abstract void WriteMethodEndForStaticCreateMethod(string instanceName);
    internal abstract void WritePropertyForStructuredType(string propertyType, string originalPropertyName, string propertyName, string fixedPropertyName, string privatePropertyName, string propertyInitializationValue, bool writeOnPropertyChanged, bool writeRequiredPropertyAttribute, int? maxPropertyDataLength, Microsoft.OData.Edm.EdmReferentialConstraint foreignKey, bool isComplex);
    internal abstract void WriteINotifyPropertyChangedImplementation();
    internal abstract void WriteClassEndForStructuredType();
    internal abstract void WriteNamespaceEnd();
    internal abstract void WriteEnumFlags();
    internal abstract void WriteSummaryCommentForEnumType(string enumName);
    internal abstract void WriteEnumDeclaration(string enumName, string originalEnumName, string underlyingType);
    internal abstract void WriteMemberForEnumType(string member, string originalMemberName, bool last);
    internal abstract void WriteEnumEnd();
    internal abstract void WritePropertyRootNamespace(string containerName, string fullNamespace);
    internal abstract void WriteFunctionImportReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string parameters, string parameterValues, bool isComposable, bool useEntityReference);
    internal abstract void WriteFunctionImportWithInputWrapperReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, bool useEntityReference);
    internal abstract void WriteFunctionImportReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference);
    internal abstract void WriteFunctionImportWithInputWrapperReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string inputWrapperTypeName, string[] parameterNames, bool isReturnEntity, bool useEntityReference);
    internal abstract void WriteBoundFunctionInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference);
    internal abstract void WriteBoundFunctionWithInputWrapperInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace, bool useEntityReference);
    internal abstract void WriteBoundFunctionInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference);
    internal abstract void WriteBoundFunctionWithInputWrapperInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string inputWrapperTypeName, string[] parameterNames, string fullNamespace, bool isReturnEntity, bool useEntityReference);
    internal abstract void WriteActionImport(string actionName, string originalActionName, string returnTypeName, string parameters, string parameterValues);
    internal abstract void WriteActionImportWithInputWrapper(string actionName, string originalActionName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames);
    internal abstract void WriteBoundActionInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues);
    internal abstract void WriteBoundActionWithInputWrapperInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace);
    internal abstract void WriteConstructorForSingleType(string singleTypeName, string baseTypeName);
    internal abstract void WriteExtensionMethodsStart();
    internal abstract void WriteExtensionMethodsEnd();
    internal abstract void WriteByKeyMethods(string entityTypeName, string returnTypeName, IEnumerable<string> keys, string keyParameters, string keyDictionaryItems);
    internal abstract void WriteCastToMethods(string baseTypeName, string derivedTypeName, string derivedTypeFullName, string returnTypeName);
    internal abstract void WriteBoundFunctionReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference);
    internal abstract void WriteBoundFunctionWithInputWrapperReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string inputWrapperTypeName, string[] parameterNames, string fullNamespace, bool isReturnEntity, bool useEntityReference);
    internal abstract void WriteBoundFunctionReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference);
    internal abstract void WriteBoundFunctionWithInputWrapperReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace, bool useEntityReference);
    internal abstract void WriteBoundActionAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string parameters, string fullNamespace, string parameterValues);
    internal abstract void WriteBoundActionWithInputWrapperAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace);

    #endregion Language specific write methods.

    internal HashSet<EdmPrimitiveTypeKind> ClrReferenceTypes { get { 
        if (clrReferenceTypes == null)
        {
            clrReferenceTypes = new HashSet<EdmPrimitiveTypeKind>()
            {
                EdmPrimitiveTypeKind.String, EdmPrimitiveTypeKind.Binary, EdmPrimitiveTypeKind.Geography, EdmPrimitiveTypeKind.Stream,
                EdmPrimitiveTypeKind.GeographyPoint, EdmPrimitiveTypeKind.GeographyLineString, EdmPrimitiveTypeKind.GeographyPolygon,
                EdmPrimitiveTypeKind.GeographyCollection, EdmPrimitiveTypeKind.GeographyMultiPolygon, EdmPrimitiveTypeKind.GeographyMultiLineString,
                EdmPrimitiveTypeKind.GeographyMultiPoint, EdmPrimitiveTypeKind.Geometry, EdmPrimitiveTypeKind.GeometryPoint,
                EdmPrimitiveTypeKind.GeometryLineString, EdmPrimitiveTypeKind.GeometryPolygon, EdmPrimitiveTypeKind.GeometryCollection,
                EdmPrimitiveTypeKind.GeometryMultiPolygon, EdmPrimitiveTypeKind.GeometryMultiLineString, EdmPrimitiveTypeKind.GeometryMultiPoint
            };
        }
        return clrReferenceTypes;
    } }
    private HashSet<EdmPrimitiveTypeKind> clrReferenceTypes;

    /// <summary>
    /// Generates code for the OData client.
    /// </summary>
    /// <returns>The generated code for the OData client.</returns>
    public override string TransformText()
    {
        this.LaunchDebugger();
        this.WriteFileHeader();
        this.WriteNamespaces();
        return this.GenerationEnvironment.ToString();
    }

    internal void WriteNamespaces()
    {
        foreach(string fullNamespace in context.NamespacesInModel)
        {
            this.WriteNamespace(fullNamespace);
        }
    }

    internal void WriteNamespace(string fullNamespace)
    {
        //System.Diagnostics.Debugger.Launch();

        this.WriteNamespaceStart(this.context.GetPrefixedNamespace(fullNamespace, this, true, false));

        IEdmSchemaElement[] schemaElements = this.context.GetSchemaElements(fullNamespace).ToArray();
        if (schemaElements.OfType<IEdmEntityContainer>().Any()) {
            IEdmEntityContainer container = schemaElements.OfType<IEdmEntityContainer>().Single();
            this.WriteEntityContainer(container, fullNamespace);
        }


        Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap = new Dictionary<IEdmStructuredType, List<IEdmOperation>>();
        Dictionary<IEdmStructuredType, List<IEdmOperation>> boundCollectionOperationsMap = new Dictionary<IEdmStructuredType, List<IEdmOperation>>();
        foreach (IEdmOperation operation in schemaElements.OfType<IEdmOperation>())
        {
            if (operation.IsBound)
            {
                IEdmType edmType = operation.Parameters.First().Type.Definition;
                if (edmType is IEdmStructuredType edmStructuredType)
                {
                    if (!boundOperationsMap.TryGetValue(edmStructuredType, out var operationList))
                    {
                        operationList = new List<IEdmOperation>();
                    }

                    operationList.Add(operation);
                    boundOperationsMap[edmStructuredType] = operationList;
                }
                else if(edmType is IEdmCollectionType collectionType)
                {
                        if (collectionType.ElementType is IEdmTypeReference referenceType)
                        {
                            if (referenceType.AsStructured().StructuredDefinition() is IEdmStructuredType boundType)
                            {
                                if (!boundCollectionOperationsMap.TryGetValue(boundType, out var operationList))
                                {
                                    operationList = new List<IEdmOperation>();
                                }

                                operationList.Add(operation);
                                boundCollectionOperationsMap[boundType] = operationList;
                            }
                        }
                }
            }
        }

        Dictionary<IEdmStructuredType, List<IEdmStructuredType>> structuredBaseTypeMap = new Dictionary<IEdmStructuredType, List<IEdmStructuredType>>();
        foreach(IEdmSchemaType type in schemaElements.OfType<IEdmSchemaType>())
        {
            if (type is IEdmEnumType enumType)
            {
                this.WriteEnumType(enumType);
            }
            else
            {
                if (type is IEdmComplexType complexType)
                {
                    this.WriteComplexType(complexType, boundOperationsMap);
                }
                else
                {
                    if (type is IEdmEntityType entityType)
                        this.WriteEntityType(entityType, boundOperationsMap, boundCollectionOperationsMap);
                }

                IEdmStructuredType structuredType = type as IEdmStructuredType;
                if (structuredType?.BaseType != null)
                {
                    if (!structuredBaseTypeMap.TryGetValue(structuredType.BaseType, out var derivedTypes))
                    {
                       structuredBaseTypeMap[structuredType.BaseType] = new List<IEdmStructuredType>();
                    }

                    structuredBaseTypeMap[structuredType.BaseType].Add(structuredType);
                }
            }
        }

        if (schemaElements.OfType<IEdmEntityType>().Any() ||
            schemaElements.OfType<IEdmOperation>().Any(o => o.IsBound))
        {
            this.WriteExtensionMethodsStart();
            foreach (IEdmEntityType type in schemaElements.OfType<IEdmEntityType>())
            {
                string entityTypeName = type.Name;
                entityTypeName = context.EnableNamingAlias ? Customization.CustomizeNaming(entityTypeName) : entityTypeName;
                string entityTypeFullName = context.GetPrefixedFullName(type, GetFixedName(entityTypeName), this);
                string returnTypeName = context.GetPrefixedFullName(type, GetFixedName(entityTypeName + this.SingleSuffix), this);

                var keyProperties = type.Key();
                if(keyProperties != null && keyProperties.Any())
                {
                    List<string> keyParameters = new List<string>();
                    List<string> keyDictionaryItems = new List<string>();
                    List<string> keyNames = new List<string>();
                    foreach (IEdmProperty key in keyProperties)
                    {
                        string typeName = Utils.GetClrTypeName(key.Type, this.context.UseDataServiceCollection, this, this.context);
                        string keyName = Utils.CamelCase(key.Name);
                        keyNames.Add(keyName);
                        keyParameters.Add(string.Format(this.ParameterDeclarationTemplate, typeName, this.GetFixedName(keyName)));
                        keyDictionaryItems.Add(string.Format(this.DictionaryItemConstructor, "\"" + key.Name + "\"", this.GetFixedName(keyName)));
                    }

                    string keyParametersString = string.Join(this.KeyParameterSeparator, keyParameters);
                    string keyDictionaryItemsString = string.Join(this.KeyDictionaryItemSeparator, keyDictionaryItems);
                    this.WriteByKeyMethods(entityTypeFullName, returnTypeName, keyNames, keyParametersString, keyDictionaryItemsString);
                }

                IEdmEntityType current = (IEdmEntityType)type.BaseType;
                while (current != null)
                {
                    string baseTypeName = current.Name;
                    baseTypeName = context.EnableNamingAlias ? Customization.CustomizeNaming(baseTypeName) : baseTypeName;
                    baseTypeName = context.GetPrefixedFullName(current, GetFixedName(baseTypeName), this);
                    this.WriteCastToMethods(baseTypeName, entityTypeName, entityTypeFullName, returnTypeName);
                    current = (IEdmEntityType)current.BaseType;
                }
            }

            HashSet<string> boundOperations = new HashSet<string>(StringComparer.Ordinal);
            foreach (IEdmFunction function in schemaElements.OfType<IEdmFunction>())
            {
                if (function.IsBound)
                {
                    IEdmTypeReference edmTypeReference = function.Parameters.First().Type;
                    string functionName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(function.Name) : function.Name;
                    this.GetParameterStrings(function.IsBound, false, function.Parameters.ToArray(), out var parameterString, out var parameterTypes, out var parameterExpressionString, out var parameterValues, out var useEntityReference);
                    string sourceTypeName = GetSourceOrReturnTypeName(edmTypeReference);
                    sourceTypeName = string.Format(edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, sourceTypeName);
                    string returnTypeName = GetSourceOrReturnTypeName(function.ReturnType);
                    string returnTypeNameWithSingleSuffix = GetSourceOrReturnTypeName(function.ReturnType, true);
                    string fixedFunctionName = GetFixedName(functionName);
                    string func = $"{fixedFunctionName}({sourceTypeName},{parameterTypes})";

                    IEdmPrimitiveType primitiveType = null;
                    IEdmStructuredType structuredType = null;
                    if (edmTypeReference.IsCollection())
                    {
                        IEdmCollectionType collectionType = edmTypeReference.Definition as IEdmCollectionType;
                        if (collectionType.ElementType.Definition.TypeKind == EdmTypeKind.Primitive)
                        {
                            primitiveType = collectionType.ElementType.Definition as IEdmPrimitiveType;
                        }
                        else
                        {
                            structuredType = collectionType.ElementType.Definition as IEdmStructuredType;
                        }
                    }
                    else
                    {
                        if (edmTypeReference.Definition.TypeKind == EdmTypeKind.Primitive)
                        {
                            primitiveType = edmTypeReference.Definition as IEdmPrimitiveType;
                        }
                        else
                        {
                            structuredType = edmTypeReference.Definition as IEdmStructuredType;
                        }
                    }

                    string[] parameterNames = function.Parameters.Skip(function.IsBound ? 1 : 0).Select(x => x.Name).ToArray(); // skip the binding/type reference parameter
                    bool generateInputWrapperClass = this.context.GenerateOperationInputWrapperClasses && parameterNames.Length > 1; // single parameters don't gain anything by using an object wrapper
                    string inputWrapperTypeName = (structuredType as IEdmType ?? primitiveType as IEdmType).FullTypeName() + "." + functionName + (edmTypeReference.IsCollection() ? WrappedCollectionOperationClassSuffix : WrappedItemOperationClassSuffix);

                    if (!boundOperations.Contains(func))
                    {
                        boundOperations.Add(func);

                        if (function.ReturnType.IsCollection())
                        {
                            this.WriteBoundFunctionReturnCollectionResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, parameterString, function.Namespace, parameterValues, function.IsComposable, useEntityReference);
                            if (generateInputWrapperClass)
                                this.WriteBoundFunctionWithInputWrapperReturnCollectionResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, inputWrapperTypeName, parameterNames, function.Namespace, useEntityReference);
                        }
                        else
                        {
                            this.WriteBoundFunctionReturnSingleResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, function.Namespace, parameterValues, function.IsComposable, function.ReturnType.IsEntity(), useEntityReference);
                            if (generateInputWrapperClass)
                                this.WriteBoundFunctionWithInputWrapperReturnSingleResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, returnTypeNameWithSingleSuffix, inputWrapperTypeName, parameterNames, function.Namespace, function.ReturnType.IsEntity(), useEntityReference);
                        }
                    }

                    if (primitiveType != null)
                    {
                        IEdmTypeReference derivedTypeReference = new EdmPrimitiveTypeReference(primitiveType, true);
                        List<IEdmTypeReference> currentParameters = function.Parameters.Select(p => p.Type).ToList();
                        currentParameters[0] = derivedTypeReference;

                        sourceTypeName = string.Format(edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, GetSourceOrReturnTypeName(derivedTypeReference));
                        string currentFunc = $"{fixedFunctionName}({sourceTypeName},{parameterTypes})";
                        if (!boundOperations.Contains(currentFunc))
                        {
                            boundOperations.Add(currentFunc);

                            if (function.ReturnType.IsCollection())
                            {
                                this.WriteBoundFunctionReturnCollectionResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, parameterString, function.Namespace, parameterValues, function.IsComposable, useEntityReference);
                                if (generateInputWrapperClass)
                                    this.WriteBoundFunctionWithInputWrapperReturnCollectionResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, inputWrapperTypeName, parameterNames, function.Namespace, useEntityReference);
                            }
                            else
                            {
                                this.WriteBoundFunctionReturnSingleResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, function.Namespace, parameterValues, function.IsComposable, function.ReturnType.IsEntity(), useEntityReference);
                                if (generateInputWrapperClass)
                                    this.WriteBoundFunctionWithInputWrapperReturnSingleResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, returnTypeNameWithSingleSuffix, inputWrapperTypeName, parameterNames, function.Namespace, function.ReturnType.IsEntity(), useEntityReference);
                            }
                        }
                    }

                    if (structuredType != null)
                    {
                        if (structuredBaseTypeMap.TryGetValue(structuredType, out var derivedTypes))
                        {
                            foreach (IEdmStructuredType type in derivedTypes)
                            {
                                IEdmTypeReference derivedTypeReference = new EdmEntityTypeReference((IEdmEntityType)type, true);
                                List<IEdmTypeReference> currentParameters = function.Parameters.Select(p => p.Type).ToList();
                                currentParameters[0] = derivedTypeReference;

                                sourceTypeName = string.Format(edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, GetSourceOrReturnTypeName(derivedTypeReference));
                                string currentFunc = $"{fixedFunctionName}({sourceTypeName},{parameterTypes})";
                                if (!boundOperations.Contains(currentFunc))
                                {
                                    boundOperations.Add(currentFunc);

                                    if (function.ReturnType.IsCollection())
                                    {
                                        this.WriteBoundFunctionReturnCollectionResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, parameterString, function.Namespace, parameterValues, function.IsComposable, useEntityReference);
                                        if (generateInputWrapperClass)
                                            this.WriteBoundFunctionWithInputWrapperReturnCollectionResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, inputWrapperTypeName, parameterNames, function.Namespace, useEntityReference);
                                    }
                                    else
                                    {
                                        this.WriteBoundFunctionReturnSingleResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, function.Namespace, parameterValues, function.IsComposable, function.ReturnType.IsEntity(), useEntityReference);
                                        if (generateInputWrapperClass)
                                            this.WriteBoundFunctionWithInputWrapperReturnSingleResultAsExtension(fixedFunctionName, function.Name, sourceTypeName, returnTypeName, returnTypeNameWithSingleSuffix, inputWrapperTypeName, parameterNames, function.Namespace, function.ReturnType.IsEntity(), useEntityReference);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            foreach (IEdmAction action in schemaElements.OfType<IEdmAction>())
            {
                if (action.IsBound)
                {
                    IEdmTypeReference edmTypeReference = action.Parameters.First().Type;
                    string actionName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(action.Name) : action.Name;
                    this.GetParameterStrings(action.IsBound, true, action.Parameters.ToArray(), out var parameterString, out var parameterTypes, out var parameterExpressionString, out var parameterValues, out var useEntityReference);
                    string sourceTypeName = GetSourceOrReturnTypeName(edmTypeReference);
                    sourceTypeName = string.Format(edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, sourceTypeName);
                    string returnTypeName;
                    if (action.ReturnType != null)
                    {
                        returnTypeName = GetSourceOrReturnTypeName(action.ReturnType);
                        returnTypeName = string.Format(action.ReturnType.IsCollection() 
                            ? this.DataServiceActionQueryOfTStructureTemplate 
                            : this.DataServiceActionQuerySingleOfTStructureTemplate, returnTypeName);
                    }
                    else
                    {
                        returnTypeName = this.DataServiceActionQueryTypeName;
                    }

                    IEdmStructuredType structuredType = null;
                    IEdmPrimitiveType primitiveType = null;
                    if (edmTypeReference.IsCollection())
                    {
                        IEdmCollectionType collectionType = edmTypeReference.Definition as IEdmCollectionType;
                        if (collectionType.ElementType.Definition.TypeKind == EdmTypeKind.Primitive)
                        {
                            primitiveType = collectionType.ElementType.Definition as IEdmPrimitiveType;
                        }
                        else
                        {
                            structuredType = collectionType.ElementType.Definition as IEdmStructuredType;
                        }
                    }
                    else
                    {
                        if (edmTypeReference.Definition.TypeKind == EdmTypeKind.Primitive)
                        {
                            primitiveType = edmTypeReference.Definition as IEdmPrimitiveType;
                        }
                        else
                        {
                            structuredType = edmTypeReference.Definition as IEdmStructuredType;
                        }
                    }

                    string fixedActionName = GetFixedName(actionName);

                    string[] parameterNames = action.Parameters.Skip(action.IsBound ? 1 : 0).Select(x => x.Name).ToArray(); // skip the binding/type reference parameter
                    bool generateInputWrapperClass = this.context.GenerateOperationInputWrapperClasses && parameterNames.Length > 1; // single parameters don't gain anything by using an object wrapper
                    string inputWrapperTypeName = (structuredType as IEdmType ?? primitiveType as IEdmType).FullTypeName() + "." + actionName + (edmTypeReference.IsCollection() ? WrappedCollectionOperationClassSuffix : WrappedItemOperationClassSuffix); 

                    string ac = $"{fixedActionName}({sourceTypeName},{parameterTypes})";
                    if (!boundOperations.Contains(ac))
                    {
                        boundOperations.Add(ac);
                        this.WriteBoundActionAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, parameterString, action.Namespace, parameterValues);
                        if(generateInputWrapperClass)
                            this.WriteBoundActionWithInputWrapperAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, inputWrapperTypeName, parameterNames, action.Namespace);
                    }

                    if (primitiveType != null)
                    {
                        IEdmTypeReference derivedTypeReference = new EdmPrimitiveTypeReference(primitiveType, true);
                        List<IEdmTypeReference> currentParameters = action.Parameters.Select(p => p.Type).ToList();
                        currentParameters[0] = derivedTypeReference;

                        sourceTypeName = string.Format(edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, GetSourceOrReturnTypeName(derivedTypeReference));
                        string currentAc = $"{fixedActionName}({sourceTypeName},{parameterTypes})";
                        if (!boundOperations.Contains(currentAc))
                        {
                            boundOperations.Add(currentAc);
                            this.WriteBoundActionAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, parameterString, action.Namespace, parameterValues);
                            if (generateInputWrapperClass)
                                this.WriteBoundActionWithInputWrapperAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, inputWrapperTypeName, parameterNames, action.Namespace);
                        }

                        // CS: I think this is a bug, this routine should not be here at all!
                        //this.WriteBoundActionAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, parameterString, action.Namespace, parameterValues);
                        //if (generateInputWrapperClass)
                        //    this.WriteBoundActionWithInputWrapperAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, inputWrapperTypeName, parameterNames, action.Namespace);
                    }

                    if (structuredType != null)
                    {
                        if (structuredBaseTypeMap.TryGetValue(structuredType, out var derivedTypes))
                        {
                            foreach (IEdmStructuredType type in derivedTypes)
                            {
                                IEdmTypeReference derivedTypeReference = new EdmEntityTypeReference((IEdmEntityType)type, true);
                                List<IEdmTypeReference> currentParameters = action.Parameters.Select(p => p.Type).ToList();
                                currentParameters[0] = derivedTypeReference;

                                sourceTypeName = string.Format(edmTypeReference.IsCollection() ? this.DataServiceQueryStructureTemplate : this.DataServiceQuerySingleStructureTemplate, GetSourceOrReturnTypeName(derivedTypeReference));
                                string currentAc = $"{fixedActionName}({sourceTypeName},{parameterTypes})";
                                if (!boundOperations.Contains(currentAc))
                                {
                                    boundOperations.Add(currentAc);
                                    this.WriteBoundActionAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, parameterString, action.Namespace, parameterValues);
                                    if(generateInputWrapperClass)
                                        this.WriteBoundActionWithInputWrapperAsExtension(fixedActionName, action.Name, sourceTypeName, returnTypeName, inputWrapperTypeName, parameterNames, action.Namespace);
                                }
                            }
                        }
                    }
                }
            }

            this.WriteExtensionMethodsEnd();
        }

        this.WriteNamespaceEnd();
    }
    
    internal bool HasBoundOperations(IEnumerable<IEdmOperation> operations)
    {
        foreach (IEdmOperation operation in operations)
        {
            if (operation.IsBound)
            {
                return true;
            }
        }

        return false;
    }

    internal void WriteEntityContainer(IEdmEntityContainer container, string fullNamespace)
    {
        string camelCaseContainerName = container.Name;
        if (this.context.EnableNamingAlias)
        {
            camelCaseContainerName = Customization.CustomizeNaming(camelCaseContainerName);
        }

        this.WriteClassStartForEntityContainer(container.Name, camelCaseContainerName, GetFixedName(camelCaseContainerName));
        this.WriteEntityContainerConstructor(container);

        if (this.context.NeedResolveNameFromType)
        {
            this.WritePropertyRootNamespace(GetFixedName(camelCaseContainerName), this.context.GetPrefixedNamespace(fullNamespace, this, false, false));
        }

        this.WriteResolveTypeFromName();
        this.WriteResolveNameFromType(camelCaseContainerName, fullNamespace);

        foreach (IEdmEntitySet entitySet in container.EntitySets())
        {
            IEdmEntityType entitySetElementType = entitySet.EntityType();
            string entitySetElementTypeName = GetElementTypeName(entitySetElementType, container);

            string camelCaseEntitySetName = entitySet.Name;
            if (this.context.EnableNamingAlias)
            {
                camelCaseEntitySetName = Customization.CustomizeNaming(camelCaseEntitySetName);
            }

            this.WriteContextEntitySetProperty(camelCaseEntitySetName, GetFixedName(camelCaseEntitySetName), entitySet.Name, GetFixedName(entitySetElementTypeName));
            if (!this.context.ElementTypeToNavigationSourceMap.TryGetValue(entitySet.EntityType(), out var edmNavigationSourceList))
            {
                edmNavigationSourceList = new List<IEdmNavigationSource>();
                this.context.ElementTypeToNavigationSourceMap.Add(entitySet.EntityType(), edmNavigationSourceList);
            }

            edmNavigationSourceList.Add(entitySet);
        }

        foreach (IEdmEntitySet entitySet in container.EntitySets())
        {
            IEdmEntityType entitySetElementType = entitySet.EntityType();
            
            string entitySetElementTypeName = GetElementTypeName(entitySetElementType, container);

            UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService(/*IsLanguageCaseSensitive*/true);
            string parameterName = GetFixedName(uniqueIdentifierService.GetUniqueParameterName(entitySetElementType.Name));

            string camelCaseEntitySetName = entitySet.Name;
            if (this.context.EnableNamingAlias)
            {
                camelCaseEntitySetName = Customization.CustomizeNaming(camelCaseEntitySetName);
            }

            this.WriteContextAddToEntitySetMethod(camelCaseEntitySetName, entitySet.Name, GetFixedName(entitySetElementTypeName), parameterName);
        }

                #region generic Attach method
                // write generic Attach method
                this.Write(@"

        /// <summary>
        /// Notifies the Microsoft.OData.Client.DataServiceContext to start tracking the
        /// specified resource and supplies the location of the resource within the specified resource set.
        /// </summary>
        /// <typeparam name=""T"">Type of the item to attach</typeparam>
        /// <param name=""item"">The resource to be tracked by the Microsoft.OData.Client.DataServiceContext, The resource is attached in the Unchanged state.</param>
        /// <remarks>It does not follow the object graph and attach related objects.</remarks>
        public void Attach<TDataItem>(TDataItem item)
             where TDataItem : Microsoft.OData.Client.BaseEntityType
        {
            switch (typeof(TDataItem))
            {
");
        foreach (IEdmEntitySet entitySet in container.EntitySets())
        {
            IEdmEntityType entitySetElementType = entitySet.EntityType();
            
            string entitySetElementTypeName = GetElementTypeName(entitySetElementType, container);

            UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService(/*IsLanguageCaseSensitive*/true);
            string parameterName = GetFixedName(uniqueIdentifierService.GetUniqueParameterName(entitySetElementType.Name));

            string camelCaseEntitySetName = entitySet.Name;
            if (this.context.EnableNamingAlias)
            {
                camelCaseEntitySetName = Customization.CustomizeNaming(camelCaseEntitySetName);
            }

            this.Write($@"                case Type t when t == typeof({GetFixedName(entitySetElementTypeName)}):
                    this.AttachTo(""{camelCaseEntitySetName}"", item);
                    break;
");
        }
        // END - write generic Attach method
        this.Write(@"

                default:
                    throw new NotImplementedException(""Have not coded for Attach type: "" + typeof(TDataItem).Name);
            }
        }
");
        #endregion generic Attach method
        foreach (IEdmSingleton singleton in container.Singletons())
        {
            IEdmEntityType singletonElementType = singleton.EntityType();
            string singletonElementTypeName = GetElementTypeName(singletonElementType, container);
            string camelCaseSingletonName = singleton.Name;
            if (this.context.EnableNamingAlias)
            {
                camelCaseSingletonName = Customization.CustomizeNaming(camelCaseSingletonName);
            }

            this.WriteContextSingletonProperty(camelCaseSingletonName, GetFixedName(camelCaseSingletonName), singleton.Name, singletonElementTypeName + "Single");

            if (this.context.ElementTypeToNavigationSourceMap.TryGetValue(singleton.EntityType(), out var edmNavigationSourceList))
            {
                edmNavigationSourceList.Add(singleton);
            }
        }

        this.WriteGeneratedEdmModel(Utils.SerializeToString(this.context.Edmx).Replace("\"", "\"\""));
        
        bool hasOperationImport = container.OperationImports().OfType<IEdmOperationImport>().Any();
        var excludedOperationImportsNames = this.context.ExcludedOperationImportsNames?.Split(',').Where(i => !string.IsNullOrWhiteSpace(i)).Select(i => i.Trim()).ToList() ?? new List<string>();
        foreach (IEdmFunctionImport functionImport in container.OperationImports().OfType<IEdmFunctionImport>())
        {
            if (excludedOperationImportsNames.Contains(functionImport.Name))
                continue;
            this.GetParameterStrings(false, false, functionImport.Function.Parameters.ToArray(), out var parameterString, out var parameterTypes, out var parameterExpressionString, out var parameterValues, out var useEntityReference);
            string returnTypeName = GetSourceOrReturnTypeName(functionImport.Function.ReturnType);
            string returnTypeNameWithSingleSuffix = GetSourceOrReturnTypeName(functionImport.Function.ReturnType, true);
            string fixedContainerName = this.GetFixedName(functionImport.Container.Name);
            bool isCollectionResult = functionImport.Function.ReturnType.IsCollection();
            string functionImportName = functionImport.Name;
            if (this.context.EnableNamingAlias)
            {
                functionImportName = Customization.CustomizeNaming(functionImportName);
                fixedContainerName = Customization.CustomizeNaming(fixedContainerName);
            }

            string[] parameterNames = functionImport.Function.Parameters.Skip(functionImport.Function.IsBound ? 1 : 0).Select(x => x.Name).ToArray(); // skip the binding/type reference parameter
            bool generateInputWrapperClass = this.context.GenerateOperationInputWrapperClasses && parameterNames.Length > 1; // single parameters don't gain anything by using an object wrapper
            string inputWrapperTypeName = fixedContainerName + "." + functionImportName + WrappedCollectionOperationClassSuffix;

            if (functionImport.Function.ReturnType.IsCollection())
            {
                this.WriteFunctionImportReturnCollectionResult(this.GetFixedName(functionImportName), functionImport.Name, returnTypeName, parameterString, parameterValues, functionImport.Function.IsComposable, useEntityReference);
                if(generateInputWrapperClass)
                    this.WriteFunctionImportWithInputWrapperReturnCollectionResult(this.GetFixedName(functionImportName), functionImport.Name, returnTypeName, inputWrapperTypeName, parameterNames, useEntityReference);
            }
            else
            {
                this.WriteFunctionImportReturnSingleResult(this.GetFixedName(functionImportName), functionImport.Name, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, parameterValues, functionImport.Function.IsComposable, functionImport.Function.ReturnType.IsEntity(), useEntityReference);
                if (generateInputWrapperClass)
                    this.WriteFunctionImportWithInputWrapperReturnSingleResult(this.GetFixedName(functionImportName), functionImport.Name, returnTypeName, returnTypeNameWithSingleSuffix, inputWrapperTypeName, parameterNames, functionImport.Function.ReturnType.IsEntity(), useEntityReference);
            }

            if (generateInputWrapperClass)
                this.WriteBoundOperationInputWrapperClass(functionImport.Function);
        }

        foreach (IEdmActionImport actionImport in container.OperationImports().OfType<IEdmActionImport>())
        {
            if (excludedOperationImportsNames.Contains(actionImport.Name))
                continue;
            this.GetParameterStrings(false, true, actionImport.Action.Parameters.ToArray(), out var parameterString, out var parameterTypes, out var parameterExpressionString, out var parameterValues, out var useEntityReference);
            string returnTypeName = null;
            string fixedContainerName = this.GetFixedName(actionImport.Container.Name);

            if (actionImport.Action.ReturnType != null)
            {
                returnTypeName = GetSourceOrReturnTypeName(actionImport.Action.ReturnType);
                returnTypeName = string.Format(actionImport.Action.ReturnType.IsCollection() 
                    ? this.DataServiceActionQueryOfTStructureTemplate 
                    : this.DataServiceActionQuerySingleOfTStructureTemplate, returnTypeName);
            }
            else
            {
                returnTypeName = this.DataServiceActionQueryTypeName;
            }

            string actionImportName = actionImport.Name;
            if (this.context.EnableNamingAlias)
            {
                actionImportName = Customization.CustomizeNaming(actionImportName);
                fixedContainerName = Customization.CustomizeNaming(fixedContainerName);
            }

            string[] parameterNames = actionImport.Action.Parameters.Skip(actionImport.Action.IsBound ? 1 : 0).Select(x => x.Name).ToArray(); // skip the binding/type reference parameter
            bool generateInputWrapperClass = this.context.GenerateOperationInputWrapperClasses && parameterNames.Length > 1; // single parameters don't gain anything by using an object wrapper
            string inputWrapperTypeName = fixedContainerName + "." + actionImportName + WrappedCollectionOperationClassSuffix;

            this.WriteActionImport(this.GetFixedName(actionImportName), actionImport.Name, returnTypeName, parameterString, parameterValues);
            if (generateInputWrapperClass)
            {
                this.WriteActionImportWithInputWrapper(this.GetFixedName(actionImportName), actionImport.Name, returnTypeName, inputWrapperTypeName, parameterNames);
                this.WriteBoundOperationInputWrapperClass(actionImport.Action);
            }
        }

        this.WriteClassEndForEntityContainer();
    }

    internal void WriteEntityContainerConstructor(IEdmEntityContainer container)
    {
        string camelCaseContainerName = container.Name;
        if (this.context.EnableNamingAlias)
        {
            camelCaseContainerName = Customization.CustomizeNaming(camelCaseContainerName);
        }
        
        this.WriteMethodStartForEntityContainerConstructor(camelCaseContainerName, GetFixedName(camelCaseContainerName));
        
        if (this.context.UseKeyAsSegmentUrlConvention(container))
        {
            this.WriteKeyAsSegmentUrlConvention();
        }

        if (this.context.NeedResolveNameFromType)
        {
            this.WriteInitializeResolveName();
        }

        if (this.context.NeedResolveTypeFromName)
        {
            this.WriteInitializeResolveType();
        }

        this.WriteClassEndForEntityContainerConstructor();
    }

    internal void WriteResolveTypeFromName()
    {
        if (!this.context.NeedResolveTypeFromName)
        {
            return;
        }

        this.WriteMethodStartForResolveTypeFromName();

        // NOTE: since multiple namespaces can have the same prefix and match the namespace
        // prefix condition, it's important that the prefix check is done is prefix-length
        // order, starting with the longest prefix.
        IEnumerable<KeyValuePair<string, string>> namespaceToPrefixedNamespacePairs = this.context.NamespaceMap.OrderByDescending(p => p.Key.Length).ThenBy(p => p.Key);
        
        string typeName = this.SystemTypeTypeName + " ";
        foreach(KeyValuePair<string, string> namespaceToPrefixedNamespacePair in namespaceToPrefixedNamespacePairs)
        {
            this.WriteResolveNamespace(typeName, namespaceToPrefixedNamespacePair.Key, namespaceToPrefixedNamespacePair.Value);
            typeName = string.Empty;
        }

        this.WriteMethodEndForResolveTypeFromName();
    }

    internal void WriteResolveNameFromType(string containerName, string fullNamespace)
    {
        if (!this.context.NeedResolveNameFromType)
        {
            return;
        }

        this.WriteMethodStartForResolveNameFromType(GetFixedName(containerName), fullNamespace);

        // NOTE: in this case order also matters, but the length of the CLR
        // namespace is what needs to be considered.
        IEnumerable<KeyValuePair<string, string>> namespaceToPrefixedNamespacePairs = this.context.NamespaceMap.OrderByDescending(p => p.Value.Length).ThenBy(p => p.Key);

        foreach(KeyValuePair<string, string> namespaceToPrefixedNamespacePair in namespaceToPrefixedNamespacePairs)
        {
            this.WriteResolveType(namespaceToPrefixedNamespacePair.Key, namespaceToPrefixedNamespacePair.Value);
        }

        this.WriteMethodEndForResolveNameFromType(this.context.ModelHasInheritance);
    }

    internal void WritePropertiesForSingleType(IEnumerable<IEdmProperty> properties)
    {
        foreach (IEdmProperty property in properties.Where(i => i.PropertyKind == EdmPropertyKind.Navigation))
        {
            string propertyType;
            string propertyName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(property.Name) : property.Name;
            if (property.Type is Microsoft.OData.Edm.EdmCollectionTypeReference)
            {
                propertyType = GetSourceOrReturnTypeName(property.Type);
                WriteContextEntitySetProperty(propertyName, GetFixedName(propertyName), property.Name, propertyType, false);
            }
            else
            {
                propertyType = Utils.GetClrTypeName(property.Type, true, this, this.context, true, isEntitySingleType : true);
                WriteContextSingletonProperty(propertyName, GetFixedName(propertyName), property.Name, propertyType, false);
            }
        }
    }

    internal void WriteEntityType(IEdmEntityType entityType, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundCollectionOperationsMap)
    {
        string entityTypeName = ((IEdmSchemaElement)entityType).Name;
        entityTypeName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(entityTypeName) : entityTypeName;
        this.WriteSummaryCommentForStructuredType(entityTypeName + this.SingleSuffix);
        this.WriteStructuredTypeDeclaration(entityType,
            this.ClassInheritMarker + string.Format(this.DataServiceQuerySingleStructureTemplate, GetFixedName(entityTypeName)),
            this.SingleSuffix);
        string singleTypeName = (this.context.EnableNamingAlias ?
            Customization.CustomizeNaming(((IEdmSchemaElement)entityType).Name) : ((IEdmSchemaElement)entityType).Name) + this.SingleSuffix;
        this.WriteConstructorForSingleType(GetFixedName(singleTypeName), string.Format(this.DataServiceQuerySingleStructureTemplate, GetFixedName(entityTypeName)));
        IEdmEntityType current = entityType;
        while (current != null)
        {
            this.WritePropertiesForSingleType(current.DeclaredProperties);
            current = (IEdmEntityType)current.BaseType;
        }

        this.WriteClassEndForStructuredType();

        this.WriteSummaryCommentForStructuredType(this.context.EnableNamingAlias ? Customization.CustomizeNaming(entityType.Name) : entityType.Name);

        if (entityType.Key().Any())
        {
            IEnumerable<string> keyProperties = entityType.Key().Select(k => k.Name);
            this.WriteKeyPropertiesCommentAndAttribute(
                this.context.EnableNamingAlias ? keyProperties.Select(k => Customization.CustomizeNaming(k)) : keyProperties,
                string.Join("\", \"", keyProperties));
        }
        else
        {
            this.WriteEntityTypeAttribute();
        }

        if (this.context.UseDataServiceCollection)
        {
            if (this.context.ElementTypeToNavigationSourceMap.TryGetValue(entityType, out var navigationSourceList))
            {
                if(navigationSourceList.Count == 1)
                {
                    this.WriteEntitySetAttribute(navigationSourceList[0].Name);
                }
            }
        }

        if (entityType.HasStream)
        {
            this.WriteEntityHasStreamAttribute();
        }

        this.WriteStructuredTypeDeclaration(entityType, this.BaseEntityType);
        this.SetPropertyIdentifierMappingsIfNameConflicts(entityType.Name, entityType);
        this.WriteTypeStaticCreateMethod(entityType.Name, entityType);
        this.WritePropertiesForStructuredType(entityType.DeclaredProperties, entityType.IsOpen);

        if (entityType.BaseType == null && this.context.UseDataServiceCollection)
        {            
            this.WriteINotifyPropertyChangedImplementation();
        }

        this.WriteBoundOperations(entityType, boundOperationsMap);

        if (this.context.GenerateOperationInputWrapperClasses)
        {
            this.WriteBoundOperationInputWrapperClasses(entityType, boundOperationsMap, boundCollectionOperationsMap);
        }

        try
        {
            this.WriteClassEndForStructuredType();
        }
        catch
        {
            
        }
       
    }

    internal void WriteComplexType(IEdmComplexType complexType, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap)
    {
        this.WriteSummaryCommentForStructuredType(this.context.EnableNamingAlias ? Customization.CustomizeNaming(complexType.Name) : complexType.Name);
        this.WriteStructuredTypeDeclaration(complexType, null);
        this.SetPropertyIdentifierMappingsIfNameConflicts(complexType.Name, complexType);
        this.WriteTypeStaticCreateMethod(complexType.Name, complexType);
        this.WritePropertiesForStructuredType(complexType.DeclaredProperties, complexType.IsOpen);

        if (complexType.BaseType == null && this.context.UseDataServiceCollection)
        {
            this.WriteINotifyPropertyChangedImplementation();
        }

        this.WriteClassEndForStructuredType();    
    }

    internal void WriteBoundOperations(IEdmStructuredType structuredType, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap)
    {
        if (boundOperationsMap.TryGetValue(structuredType, out var operations))
        {
            foreach (IEdmFunction function in operations.OfType<IEdmFunction>())
            {
                bool hideBaseMethod = this.CheckMethodsInBaseClass(structuredType.BaseType, function, boundOperationsMap);
                this.GetParameterStrings(function.IsBound, false, function.Parameters.ToArray(), out var parameterString, out var parameterTypes, out var parameterExpressionString, out var parameterValues, out var useEntityReference);
                string returnTypeName = GetSourceOrReturnTypeName(function.ReturnType);
                string returnTypeNameWithSingleSuffix = GetSourceOrReturnTypeName(function.ReturnType, true);
                string functionName = function.Name;
                if (this.context.EnableNamingAlias)
                {
                    functionName = Customization.CustomizeNaming(functionName);
                }

                string[] parameterNames = function.Parameters.Skip(function.IsBound ? 1 : 0).Select(x => x.Name).ToArray(); // skip the binding/type reference parameter
                bool generateInputWrapperClass = this.context.GenerateOperationInputWrapperClasses && parameterNames.Length > 1; // single parameters don't gain anything by using an object wrapper
                string inputWrapperTypeName = structuredType.FullTypeName() + "." + GetFixedName(functionName) + (structuredType.TypeKind == EdmTypeKind.Collection ? WrappedCollectionOperationClassSuffix : WrappedItemOperationClassSuffix);

                if (function.ReturnType.IsCollection())
                {
                    this.WriteBoundFunctionInEntityTypeReturnCollectionResult(hideBaseMethod, GetFixedName(functionName), function.Name, returnTypeName, parameterString, function.Namespace, parameterValues, function.IsComposable, useEntityReference);
                    if (generateInputWrapperClass)
                        this.WriteBoundFunctionWithInputWrapperInEntityTypeReturnCollectionResult(hideBaseMethod, GetFixedName(functionName), function.Name, returnTypeName, inputWrapperTypeName, parameterNames, function.Namespace, useEntityReference);
                }
                else
                {
                    this.WriteBoundFunctionInEntityTypeReturnSingleResult(hideBaseMethod, GetFixedName(functionName), function.Name, returnTypeName, returnTypeNameWithSingleSuffix, parameterString, function.Namespace, parameterValues, function.IsComposable, function.ReturnType.IsEntity(), useEntityReference);
                    if (generateInputWrapperClass)
                        this.WriteBoundFunctionWithInputWrapperInEntityTypeReturnSingleResult(hideBaseMethod, GetFixedName(functionName), function.Name, returnTypeName, returnTypeNameWithSingleSuffix, inputWrapperTypeName, parameterNames, function.Namespace, function.ReturnType.IsEntity(), useEntityReference);
                }
            }

            foreach (IEdmAction action in operations.OfType<IEdmAction>())
            {
                bool hideBaseMethod = this.CheckMethodsInBaseClass(structuredType.BaseType, action, boundOperationsMap);
                this.GetParameterStrings(action.IsBound, true, action.Parameters.ToArray(), out var parameterString, out var parameterTypes, out var parameterExpressionString, out var parameterValues, out var useEntityReference);
                string returnTypeName;
                if (action.ReturnType != null)
                {
                    returnTypeName = GetSourceOrReturnTypeName(action.ReturnType);
                    returnTypeName = string.Format(action.ReturnType.IsCollection()
                        ? this.DataServiceActionQueryOfTStructureTemplate
                        : this.DataServiceActionQuerySingleOfTStructureTemplate, returnTypeName);
                }
                else
                {
                    returnTypeName = this.DataServiceActionQueryTypeName;
                }

                string actionName = action.Name;
                if (this.context.EnableNamingAlias)
                {
                    actionName = Customization.CustomizeNaming(actionName);
                }

                this.WriteBoundActionInEntityType(hideBaseMethod, GetFixedName(actionName), action.Name, returnTypeName, parameterString, action.Namespace, parameterValues);

                string[] parameterNames = action.Parameters.Skip(action.IsBound ? 1 : 0).Select(x => x.Name).ToArray(); // skip the binding/type reference parameter
                bool generateInputWrapperClass = this.context.GenerateOperationInputWrapperClasses && parameterNames.Length > 1; // single parameters don't gain anything by using an object wrapper
                if (generateInputWrapperClass)
                {
                    string inputWrapperTypeName = structuredType.FullTypeName() + "." + GetFixedName(actionName) + (structuredType.TypeKind == EdmTypeKind.Collection ? WrappedCollectionOperationClassSuffix : WrappedItemOperationClassSuffix);

                    this.WriteBoundActionWithInputWrapperInEntityType(hideBaseMethod, GetFixedName(actionName), action.Name, returnTypeName, inputWrapperTypeName, parameterNames, action.Namespace);
                }
            }

        }
    }
    internal void WriteBoundOperationInputWrapperClasses(IEdmStructuredType structuredType, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundCollectionOperationsMap)
    {
        List<IEdmOperation> operations = new List<IEdmOperation>();

        if (boundOperationsMap.TryGetValue(structuredType, out var itemOperations))
        {
            operations.AddRange(itemOperations);
        }
        if (boundCollectionOperationsMap.TryGetValue(structuredType, out var collectionOperations))
        {
            operations.AddRange(collectionOperations);
        }

        if (operations.Any())
        {
            this.PushIndent("    ");

            foreach (var operation in operations)
            {
                // only generate input wrapper classes for operations that have more than 1 single parameter.
                if (operation.Parameters.Skip(operation.IsBound ? 1 : 0).Count() > 1) 
                {
                    WriteBoundOperationInputWrapperClass(operation);
                }
            }

            this.PopIndent();

        }
    }

    internal bool CheckMethodsInBaseClass(IEdmStructuredType structuredType, IEdmOperation operation, Dictionary<IEdmStructuredType, List<IEdmOperation>> boundOperationsMap)
    {
        if (structuredType != null)
        {
            if (boundOperationsMap.TryGetValue(structuredType, out var operations))
            {
                foreach (IEdmOperation op in operations)
                {
                    if (this.context.TargetLanguage == LanguageOption.VB)
                    {
                        if (operation.Name == op.Name)
                        {
                            return true;
                        }
                    }

                    List<IEdmOperationParameter> targetParameter = operation.Parameters.ToList();
                    List<IEdmOperationParameter> checkParameter = op.Parameters.ToList();
                    if (operation.Name == op.Name && targetParameter.Count == checkParameter.Count)
                    {
                        bool areSame = true;
                        for (int i = 1; i < targetParameter.Count; ++i)
                        {
                            var targetParameterType = targetParameter[i].Type;
                            var checkParameterType = checkParameter[i].Type;
                            if (!targetParameterType.Definition.Equals(checkParameterType.Definition)
                                || targetParameterType.IsNullable != checkParameterType.IsNullable)
                            {
                                areSame = false;
                                break;
                            }
                        }

                        if (areSame)
                        {
                            return true;
                        }
                    }
                }
            }

            return CheckMethodsInBaseClass(structuredType.BaseType, operation, boundOperationsMap);
        }

        return false;
    }

    internal void WriteEnumType(IEdmEnumType enumType)
    {
        this.WriteSummaryCommentForEnumType(this.context.EnableNamingAlias ? Customization.CustomizeNaming(enumType.Name) : enumType.Name);
        if (enumType.IsFlags)
        {
            this.WriteEnumFlags();
        }

        string underlyingType = string.Empty;
        if (enumType.UnderlyingType != null && enumType.UnderlyingType.PrimitiveKind != EdmPrimitiveTypeKind.Int32)
        {
            underlyingType = Utils.GetClrTypeName(enumType.UnderlyingType, this);
            underlyingType = this.EnumUnderlyingTypeMarker + underlyingType;
        }

        this.WriteEnumDeclaration(this.context.EnableNamingAlias ? GetFixedName(Customization.CustomizeNaming(enumType.Name)) : GetFixedName(enumType.Name), enumType.Name, underlyingType);
        this.WriteMembersForEnumType(enumType.Members);
        this.WriteEnumEnd();
    }

    internal void WriteStructuredTypeDeclaration(IEdmStructuredType structuredType, string baseEntityType, string typeNameSuffix = null)
    {
        string abstractModifier = structuredType.IsAbstract && typeNameSuffix == null ? this.AbstractModifier : string.Empty;
        string baseTypeName = baseEntityType;

        if (typeNameSuffix == null)
        {
            if (structuredType.BaseType == null)
            {
                if (this.context.UseDataServiceCollection)
                {
                    if (this.context.TargetLanguage == LanguageOption.CSharp)
                    {
                        baseTypeName += string.IsNullOrEmpty(baseTypeName) ? this.ClassInheritMarker : ", ";
                        if (structuredType.TypeKind == EdmTypeKind.Complex)
                        {
                            // SDSS ValueChange needs to handle ComplexTypes differently
                            baseTypeName += "IComplexType, ";
                        }
                    }

                    baseTypeName += this.NotifyPropertyChangedModifier;
                }
            }
            else
            {
                IEdmSchemaElement baseType = (IEdmSchemaElement)structuredType.BaseType;
                string baseTypeFixedName = this.context.EnableNamingAlias ? GetFixedName(Customization.CustomizeNaming(baseType.Name)) : GetFixedName(baseType.Name);
                baseTypeName = ((IEdmSchemaElement)structuredType).Namespace == baseType.Namespace ? baseTypeFixedName : this.context.GetPrefixedFullName(baseType, baseTypeFixedName, this);
                baseTypeName = this.ClassInheritMarker + baseTypeName;
            }
        }

        string structuredTypeName = this.context.EnableNamingAlias ?
            Customization.CustomizeNaming(((IEdmSchemaElement)structuredType).Name) : ((IEdmSchemaElement)structuredType).Name;

        this.WriteGeneratedCodeAttribute();
        this.WriteClassStartForStructuredType(abstractModifier, GetFixedName(structuredTypeName + typeNameSuffix), ((IEdmSchemaElement)structuredType).Name + typeNameSuffix, baseTypeName);
    }
    
    internal string GetSourceOrReturnTypeName(IEdmTypeReference typeReference, bool isEntitySingleType = false)
    {
        IEdmCollectionType edmCollectionType = typeReference.Definition as IEdmCollectionType;
        bool addNullableTemplate = true;
        if (edmCollectionType != null)
        {
            typeReference = edmCollectionType.ElementType;
            addNullableTemplate = false;
        }

        return Utils.GetClrTypeName(typeReference, this.context.UseDataServiceCollection, this, this.context, addNullableTemplate, isEntitySingleType:isEntitySingleType);
    }
    
    internal void GetParameterStrings(bool isBound, bool isAction, IEdmOperationParameter[] parameters, out string parameterString, out string parameterTypes, out string parameterExpressionString, out string parameterValues,  out bool useEntityReference)
    {
        parameterString = string.Empty;
        parameterExpressionString = string.Empty;
        parameterTypes = string.Empty;
        parameterValues = string.Empty;
        useEntityReference = false;

        int n = parameters.Count();
        for (int i = isBound ? 1 : 0; i < n; ++i)
        {
            IEdmOperationParameter param = parameters[i];
            if (i == (isBound ? 1 : 0))
            {
                if (this.context.TargetLanguage == LanguageOption.CSharp)
                {
                    parameterExpressionString += "\r\n                        ";
                }
                else
                {
                    parameterExpressionString += "\r\n                            ";
                }
            }
            
            string typeName = Utils.GetClrTypeName(param.Type, this.context.UseDataServiceCollection, this, this.context, true, true, true);
            if (this.context.TargetLanguage == LanguageOption.CSharp)
            {
                parameterString += typeName;
                parameterString += (" " + GetFixedName(param.Name));
            }
            else if (this.context.TargetLanguage == LanguageOption.VB)
            {
                parameterString += GetFixedName(param.Name);
                parameterString += (this.EnumUnderlyingTypeMarker + typeName);
            }
            
            parameterString += i == n - 1 ? string.Empty : ", ";
            parameterTypes += string.Format(this.TypeofFormatter, typeName) + ", ";
            parameterExpressionString += this.GetParameterExpressionString(param, typeName) + ", ";
            
            if (i != (isBound ? 1 : 0))
            {
                parameterValues += ",\r\n                    ";
            }
            
            if (isAction)
            {
                parameterValues += string.Format(this.BodyOperationParameterConstructor, param.Name, GetFixedName(param.Name));
            }
            else  if (param.Type.IsEntity() || (param.Type.IsCollection() && param.Type.AsCollection().ElementType().IsEntity()))
            {
                useEntityReference = true;
                parameterValues += string.Format(this.UriEntityOperationParameterConstructor, param.Name, GetFixedName(param.Name),"useEntityReference");
            }
            else
            {
                parameterValues += string.Format(this.UriOperationParameterConstructor, param.Name, GetFixedName(param.Name));
            }
        }
    }

    internal string GetParameterExpressionString(IEdmOperationParameter param, string typeName)
    {
        IEdmType edmType = param.Type.Definition;
        if (edmType is IEdmPrimitiveType edmPrimitiveType)
        {
            var clrTypeName = Utils.GetClrTypeName(edmPrimitiveType, this);                
            if (param.Type.IsNullable && !this.ClrReferenceTypes.Contains(edmPrimitiveType.PrimitiveKind))
            {
                clrTypeName += "?";
            }

            return string.Format(this.ConstantExpressionConstructorWithType, GetFixedName(param.Name), clrTypeName);
        }

        return string.Format(this.ConstantExpressionConstructorWithType, GetFixedName(param.Name), typeName); 
    }

    // This is to solve duplicate names between property and type
    internal void SetPropertyIdentifierMappingsIfNameConflicts(string typeName, IEdmStructuredType structuredType)
    {
        if (this.context.EnableNamingAlias)
        {
            typeName = Customization.CustomizeNaming(typeName);
        }

        // PropertyName in VB is case-insensitive.
        bool isLanguageCaseSensitive = this.context.TargetLanguage == LanguageOption.CSharp;

        // In VB, it is allowed that a type has a property whose name is same with the type's name
        bool allowPropertyNameSameWithTypeName = this.context.TargetLanguage == LanguageOption.VB;

        Func<string, string> customizePropertyName = (name) => { return this.context.EnableNamingAlias ? Customization.CustomizeNaming(name) : name; };

        var propertyGroups = structuredType.Properties()
            .GroupBy(p => isLanguageCaseSensitive ? customizePropertyName(p.Name) : customizePropertyName(p.Name).ToUpperInvariant());

        // If the group contains more than one property, or the property in the group has the same name with the type (only for C#), we need to rename the property
        var propertyToBeRenamedGroups = propertyGroups.Where(g => g.Count() > 1 || !allowPropertyNameSameWithTypeName && g.Key == typeName);

        var knownIdentifiers = propertyGroups.Select(g => customizePropertyName(g.First().Name)).ToList();
        if (!allowPropertyNameSameWithTypeName && !knownIdentifiers.Contains(typeName))
        {
            knownIdentifiers.Add(typeName);
        }

        UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService(knownIdentifiers, isLanguageCaseSensitive);

        IdentifierMappings.Clear();
        foreach (IGrouping<string, IEdmProperty> g in propertyToBeRenamedGroups)
        { 
            bool hasPropertyNameSameWithCustomizedPropertyName = false;
            int itemCount = g.Count();
            for (int i = 0; i < itemCount; i++)
            {
                var property = g.ElementAt(i);
                var customizedPropertyName = customizePropertyName(property.Name);

                if (this.context.EnableNamingAlias && customizedPropertyName == property.Name)
                {
                    hasPropertyNameSameWithCustomizedPropertyName = true;
                }
                
                if(isLanguageCaseSensitive)
                {
                    // If a property name is same as its customized property name, then we don't rename it.
                    // Or we don't rename the last property in the group
                    if(customizedPropertyName != typeName
                        && (customizedPropertyName == property.Name
                            || (!hasPropertyNameSameWithCustomizedPropertyName && i == itemCount-1)))
                    {
                        continue;
                    }
                }
                else
                {
                    // When EnableNamingAlias = true, If a property name is same as its customized property name, then we don't rename it.
                    // Or we don't rename the last property in the group.
                    if((this.context.EnableNamingAlias && customizedPropertyName == property.Name)
                        || (!hasPropertyNameSameWithCustomizedPropertyName && i == itemCount-1))
                    {
                        continue;
                    }
                }
                var renamedPropertyName = uniqueIdentifierService.GetUniqueIdentifier(customizedPropertyName);
                    IdentifierMappings.Add(property.Name, renamedPropertyName);
            }
        }
    }

    internal void WriteTypeStaticCreateMethod(string typeName, IEdmStructuredType structuredType)
    {
        Debug.Assert(structuredType != null, "structuredType != null");
        if (structuredType.IsAbstract)
        {
            return;
        }

        Func<IEdmProperty, bool> hasDefault = p => p.PropertyKind == EdmPropertyKind.Structural && ((IEdmStructuralProperty)p).DefaultValueString != null;

        if (this.context.EnableNamingAlias)
        {
            typeName = Customization.CustomizeNaming(typeName);
        }

        IEnumerable<IEdmProperty> parameters = structuredType.Properties()
            .Where(p => !p.Type.IsNullable && !p.Type.IsCollection() && !hasDefault(p));
        if (!parameters.Any())
        {
            return;
        }

        this.WriteSummaryCommentForStaticCreateMethod(typeName);

        UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService( /*IsLanguageCaseSensitive*/true);
        string instanceName = GetFixedName(uniqueIdentifierService.GetUniqueParameterName(typeName));
        KeyValuePair<IEdmProperty, string>[] propertyToParameterNamePairs = parameters
            .Select(p =>
                new KeyValuePair<IEdmProperty, string>(p,
                    uniqueIdentifierService.GetUniqueParameterName(
                        IdentifierMappings.ContainsKey(p.Name) ? IdentifierMappings[p.Name] : p.Name)))
            .ToArray();

        foreach (var propertyToParameterNamePair in propertyToParameterNamePairs)
        {
            string propertyName = propertyToParameterNamePair.Key.Name;
            propertyName = IdentifierMappings.ContainsKey(propertyName) ?
                IdentifierMappings[propertyName] : (this.context.EnableNamingAlias ? Customization.CustomizeNaming(propertyName) : propertyName);
            this.WriteParameterCommentForStaticCreateMethod(propertyToParameterNamePair.Value, propertyName);
        }

        propertyToParameterNamePairs = propertyToParameterNamePairs
            .Select(p => p = new KeyValuePair<IEdmProperty, string>(p.Key, GetFixedName(p.Value)))
            .ToArray();

        this.WriteDeclarationStartForStaticCreateMethod(typeName, GetFixedName(typeName));
        this.WriteStaticCreateMethodParameters(propertyToParameterNamePairs);
        this.WriteDeclarationEndForStaticCreateMethod(GetFixedName(typeName), instanceName);

        foreach (var propertyToParameterNamePair in propertyToParameterNamePairs)
        {
            IEdmProperty property = propertyToParameterNamePair.Key;
            string parameterName = propertyToParameterNamePair.Value;

            Debug.Assert(!property.Type.IsCollection(), "!property.Type.IsCollection()");
            Debug.Assert(!property.Type.IsNullable, "!property.Type.IsNullable");
            
            // The static create method only sets non-nullable properties. We should add the null check if the type of the property is not a clr ValueType.
            // For now we add the null check if the property type is non-primitive. We should add the null check for non-ValueType primitives in the future.
            if (!property.Type.IsPrimitive() && !property.Type.IsEnum())
            {
                this.WriteParameterNullCheckForStaticCreateMethod(parameterName);
            }

            var uniqIdentifier = IdentifierMappings.ContainsKey(property.Name) ?
                IdentifierMappings[property.Name] : (this.context.EnableNamingAlias ? Customization.CustomizeNaming(property.Name) : property.Name);
            this.WritePropertyValueAssignmentForStaticCreateMethod(instanceName,
                GetFixedName(uniqIdentifier),
                parameterName);
        }

        this.WriteMethodEndForStaticCreateMethod(instanceName);
    }

    internal void WriteStaticCreateMethodParameters(KeyValuePair<IEdmProperty, string>[] propertyToParameterPairs)
    {
        if (propertyToParameterPairs.Length == 0)
        {
            return;
        }

        // If the number of parameters are greater than 5, we put them in separate lines.
        string parameterSeparator = propertyToParameterPairs.Length > 5 ? this.ParameterSeparator : ", ";
        for (int idx = 0; idx < propertyToParameterPairs.Length; idx++)
        {
            KeyValuePair<IEdmProperty, string> propertyToParameterPair = propertyToParameterPairs[idx];

            string parameterType = Utils.GetClrTypeName(propertyToParameterPair.Key.Type, this.context.UseDataServiceCollection, this, this.context);
            string parameterName = propertyToParameterPair.Value;
            if (idx == propertyToParameterPairs.Length - 1)
            {
                // No separator after the last parameter.
                parameterSeparator = string.Empty;
            }

            this.WriteParameterForStaticCreateMethod(parameterType, GetFixedName(parameterName), parameterSeparator);
        }
    }

    internal void WritePropertiesForStructuredType(IEnumerable<IEdmProperty> properties, bool isOpen)
    {
        bool useDataServiceCollection = this.context.UseDataServiceCollection;

        var propertyInfos = properties.Select(property =>
        {
            string propertyName = IdentifierMappings.ContainsKey(property.Name) ?
                IdentifierMappings[property.Name] : (this.context.EnableNamingAlias ? Customization.CustomizeNaming(property.Name) : property.Name);

            // Lookup MaxLength for string fields
            int? maxLength = null;
            if (property.Type.TypeKind() == EdmTypeKind.Primitive)
            {
                var csdlTypeElement = property.Type.GetType().GetProperty("Element").GetValue(property.Type);
                bool isUnbounded = (bool)csdlTypeElement.GetType().GetProperty("IsUnbounded")?.GetValue(csdlTypeElement);
                maxLength = isUnbounded ? -1 : (int?)csdlTypeElement.GetType().GetProperty("MaxLength")?.GetValue(csdlTypeElement);
            }

            // try to extract foreignKey info
            Microsoft.OData.Edm.EdmReferentialConstraint foreignKey = null;
            if (property.PropertyKind == EdmPropertyKind.Navigation)
            {
                foreignKey = property.GetType().GetProperty("ReferentialConstraint")?.GetValue(property) as Microsoft.OData.Edm.EdmReferentialConstraint;
            }

            return new
                {
                    PropertyType = Utils.GetClrTypeName(property.Type, useDataServiceCollection, this, this.context),
                    PropertyVanillaName = property.Name,
                    PropertyName = propertyName,
                    FixedPropertyName = GetFixedName(propertyName),
                    PrivatePropertyName = "_" + propertyName,
                    PropertyInitializationValue = Utils.GetPropertyInitializationValue(property, useDataServiceCollection, this, this.context),
                    Required = false,
                    MaxLength = maxLength,
                    ForeignKey = foreignKey,
                    IsComplex = property.Type.IsComplex()
                };
        }).ToList();

        if (isOpen && this.context.GenerateDynamicPropertiesCollection)
        {
            propertyInfos.Add(new
            {
                PropertyType = string.Format(this.DictionaryTypeName, this.StringTypeName, this.ObjectTypeName),
                PropertyVanillaName = string.Empty, // No such property in metadata
                PropertyName = this.context.DynamicPropertiesCollectionName,
                FixedPropertyName = GetFixedName(this.context.DynamicPropertiesCollectionName),
                PrivatePropertyName = "_" + Utils.CamelCase(this.context.DynamicPropertiesCollectionName),
                PropertyInitializationValue = string.Format(this.DictionaryConstructor, this.StringTypeName, this.ObjectTypeName),
                Required = false,
                MaxLength = (int?)null,
                ForeignKey = (Microsoft.OData.Edm.EdmReferentialConstraint)null,
                IsComplex = false // ? maybe this is true ?
            });
        }

        // Private name should not conflict with field name
        UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService(propertyInfos.Select(_ => _.FixedPropertyName),
            this.context.TargetLanguage == LanguageOption.CSharp);

        foreach (var propertyInfo in propertyInfos)
        {
            string privatePropertyName = uniqueIdentifierService.GetUniqueIdentifier("_" + propertyInfo.PropertyName);

            this.WritePropertyForStructuredType(
                propertyInfo.PropertyType,
                propertyInfo.PropertyVanillaName,
                propertyInfo.PropertyName,
                propertyInfo.FixedPropertyName,
                privatePropertyName,
                propertyInfo.PropertyInitializationValue,
                useDataServiceCollection,
                propertyInfo.Required,
                propertyInfo.MaxLength,
                propertyInfo.ForeignKey,
                propertyInfo.IsComplex);
        }
    }

    internal void WriteMembersForEnumType(IEnumerable<IEdmEnumMember> members)
    {
        int n = members.Count();
        for (int idx = 0; idx < n; ++idx)
        {
            IEdmEnumMember member = members.ElementAt(idx);
            string value = string.Empty;
            if (member.Value != null)
            {
                if (member.Value is IEdmEnumMemberValue integerValue)
                {
                    value = " = " + integerValue.Value.ToString(CultureInfo.InvariantCulture);
                }
            }

            string memberName = this.context.EnableNamingAlias ? Customization.CustomizeNaming(member.Name) : member.Name;
            this.WriteMemberForEnumType(GetFixedName(memberName) + value, member.Name, idx == n - 1);
        }
    }

    internal string GetFixedName(string originalName)
    {
        string fixedName = originalName;

        if (this.LanguageKeywords.Contains(fixedName))
        {
            fixedName = string.Format(this.FixPattern, fixedName);
        }

        return fixedName;
    }

    internal string GetElementTypeName(IEdmEntityType elementType, IEdmEntityContainer container)
    {
        string elementTypeName = elementType.Name;

        if (this.context.EnableNamingAlias)
        {
            elementTypeName = Customization.CustomizeNaming(elementTypeName);
        }

        if (elementType.Namespace != container.Namespace)
        {
            elementTypeName = this.context.GetPrefixedFullName(elementType, GetFixedName(elementTypeName), this);
        }

        return elementTypeName;
    }

    /// <summary>
    /// Write a class to the input parameters for a bound operation so that only a single argument object needs to be passed around
    /// This is designed to write as a nested class of the type that the operation is bound to to reduce possibility of name and structure clashes.
    /// </summary>
    /// <remarks>If the API has multiple operations with the same argument signature and you wish to re-use this as a single type reference then that should be 
    /// Implemented as a fixed type at the API level, don't try to be too smart in the client-side generation</remarks>
    /// <param name="operation">The operation to generate an argument wrapper class</param>
    internal void WriteBoundOperationInputWrapperClass(IEdmOperation operation)
    {
        if (operation.IsBound)
        {
            IEdmTypeReference edmTypeReference = operation.Parameters.First().Type;

            // use GetParameterString as it formats types and names consistently
            this.GetParameterStrings(operation.IsBound, operation.IsAction(), operation.Parameters.ToArray(), out var parameterString, out var parameterTypes, out var parameterExpressionString, out var parameterValues, out var useEntityReference);
            var propertyDeclarations = parameterString.Split(',');
            string[] propertyNames = null;
            string[] propertyTypes = null;
            if (this.context.TargetLanguage == LanguageOption.CSharp)
            {
                propertyNames = propertyDeclarations.Where(x => x.Contains(' ')).Select(x => x.Substring(x.LastIndexOf(' ') + 1)).ToArray();
                propertyTypes = propertyDeclarations.Where(x => x.Contains(' ')).Select(x => x.Substring(0, x.LastIndexOf(' '))).ToArray();
            }
            else
            {
                propertyTypes = propertyDeclarations.Where(x => x.Contains(' ')).Select(x => x.Substring(x.LastIndexOf(' ') + 1)).ToArray();
                propertyNames = propertyDeclarations.Where(x => x.Contains(' ')).Select(x => x.Substring(0, x.LastIndexOf(' '))).ToArray();
            }

            // TODO: implement comments for this generated structure... 
            //this.WriteSummaryCommentForStructuredType(requestClassName);

            string baseTypeName = String.Empty;
            if (this.context.UseDataServiceCollection)
            {
                if (this.context.TargetLanguage == LanguageOption.CSharp)
                {
                    baseTypeName += string.IsNullOrEmpty(baseTypeName) ? this.ClassInheritMarker : ", ";
                }

                baseTypeName += this.NotifyPropertyChangedModifier;
            }

            this.WriteGeneratedCodeAttribute();
            string inputWrapperTypeName = operation.Name + (edmTypeReference.IsCollection() ? WrappedCollectionOperationClassSuffix : WrappedItemOperationClassSuffix);
            this.WriteClassStartForStructuredType(String.Empty, inputWrapperTypeName, operation.Name, baseTypeName);

            // Private name should not conflict with field name
            UniqueIdentifierService uniqueIdentifierService = new UniqueIdentifierService(propertyNames, this.context.TargetLanguage == LanguageOption.CSharp);
            string[] declarations = parameterExpressionString.Trim().Split(',');
            for (int i = 0; i < propertyNames.Length; i++)
            {
                var propertyName = propertyNames[i];
                var propertyType = propertyTypes[i];
                string privatePropertyName = uniqueIdentifierService.GetUniqueIdentifier("_" + propertyName);
                var required = !declarations[i].ToLower().Contains("optional");

                // we can get additional validation information from the CSL definition
                var parameter = operation.Parameters.First(x => x.Name == propertyName);
                var csdlElement = parameter.GetType().GetProperty("Element").GetValue(parameter); // expecting internal Microsoft.OData.Edm.Csdl.CsdlSemantics.CsdlSemanticsOperationParameter
                bool isOptional = (bool)csdlElement.GetType().GetProperty("IsOptional").GetValue(csdlElement);

                this.WritePropertyForStructuredType(
                    propertyType,
                    propertyName,
                    propertyName,
                    GetFixedName(propertyName),
                    privatePropertyName,
                    this.context.TargetLanguage == LanguageOption.CSharp ? "default" : "Nothing",
                    this.context.UseDataServiceCollection,
                    !isOptional,
                    null,
                    null,
                    parameter.Type.IsComplex()
                    );
            }

            WriteINotifyPropertyChangedImplementation();
            this.WriteClassEndForStructuredType();
        }
    }

}

/// <summary>
/// Base class for text transformation
/// </summary>
[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "11.0.0.0")]
public abstract class TemplateBase
{
    #region Fields
    private global::System.Text.StringBuilder generationEnvironmentField;
    private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
    private global::System.Collections.Generic.List<int> indentLengthsField;
    private string currentIndentField = "";
    private bool endsWithNewline;
    private global::System.Collections.Generic.IDictionary<string, object> sessionField;
    #endregion
    #region Properties
    /// <summary>
    /// The string builder that generation-time code is using to assemble generated output
    /// </summary>
    protected System.Text.StringBuilder GenerationEnvironment
    {
        get
        {
            if ((this.generationEnvironmentField == null))
            {
                this.generationEnvironmentField = new global::System.Text.StringBuilder();
            }
            return this.generationEnvironmentField;
        }
        set => this.generationEnvironmentField = value;
    }
    /// <summary>
    /// The error collection for the generation process
    /// </summary>
    public System.CodeDom.Compiler.CompilerErrorCollection Errors
    {
        get
        {
            if ((this.errorsField == null))
            {
                this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
            }
            return this.errorsField;
        }
    }
    /// <summary>
    /// A list of the lengths of each indent that was added with PushIndent
    /// </summary>
    private System.Collections.Generic.List<int> indentLengths
    {
        get
        {
            if ((this.indentLengthsField == null))
            {
                this.indentLengthsField = new global::System.Collections.Generic.List<int>();
            }
            return this.indentLengthsField;
        }
    }
    /// <summary>
    /// Gets the current indent we use when adding lines to the output
    /// </summary>
    public string CurrentIndent => this.currentIndentField;

    /// <summary>
    /// Current transformation session
    /// </summary>
    public virtual global::System.Collections.Generic.IDictionary<string, object> Session
    {
        get => this.sessionField;
        set => this.sessionField = value;
    }
    #endregion

    /// <summary>
    /// Create the template output
    /// </summary>
    public abstract string TransformText();

    #region Transform-time Debugging Helpers

    /// <summary>
    /// Write out the <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> for a member that declares the name of this tool and the current version.
    /// If this is a debug build, the name of the calling method that executed this method will be injected as the Tool to assist with debugging and extension development
    /// </summary>
    /// <param name="member">Name of the method that called into this method</param>
    /// <remarks>Member name is only visible during debugging</remarks>
    internal abstract void WriteGeneratedCodeAttribute([System.Runtime.CompilerServices.CallerMemberName] string member = null);

    /// <summary>
    /// Launch and attach the debugger to the process that is executing the generation
    /// </summary>
    /// <remarks>this is to assist live debugging of the generation logic</remarks>
    [System.Diagnostics.Conditional("DEBUG")]
    public void LaunchDebugger()
    {
        //System.Diagnostics.Debugger.Launch();
    }

#endregion Transform-time Debugging Helpers


#region Transform-time helpers

    /// <summary>
    /// Write text directly into the generated output
    /// </summary>
    public void Write(string textToAppend)
    {
        if (string.IsNullOrEmpty(textToAppend))
        {
            return;
        }
        // If we're starting off, or if the previous text ended with a newline,
        // we have to append the current indent first.
        if (((this.GenerationEnvironment.Length == 0) 
                    || this.endsWithNewline))
        {
            this.GenerationEnvironment.Append(this.currentIndentField);
            this.endsWithNewline = false;
        }
        // Check if the current text ends with a newline
        if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
        {
            this.endsWithNewline = true;
        }
        // This is an optimization. If the current indent is "", then we don't have to do any
        // of the more complex stuff further down.
        if ((this.currentIndentField.Length == 0))
        {
            this.GenerationEnvironment.Append(textToAppend);
            return;
        }
        // Everywhere there is a newline in the text, add an indent after it
        textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
        // If the text ends with a newline, then we should strip off the indent added at the very end
        // because the appropriate indent will be added when the next time Write() is called
        if (this.endsWithNewline)
        {
            this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
        }
        else
        {
            this.GenerationEnvironment.Append(textToAppend);
        }
    }
    /// <summary>
    /// Write text directly into the generated output
    /// </summary>
    public void WriteLine(string textToAppend)
    {
        this.Write(textToAppend);
        this.GenerationEnvironment.AppendLine();
        this.endsWithNewline = true;
    }
    /// <summary>
    /// Write formatted text directly into the generated output
    /// </summary>
    public void Write(string format, params object[] args)
    {
        this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
    }
    /// <summary>
    /// Write formatted text directly into the generated output
    /// </summary>
    public void WriteLine(string format, params object[] args)
    {
        this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
    }
    /// <summary>
    /// Raise an error
    /// </summary>
    public void Error(string message)
    {
        System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
        error.ErrorText = message;
        this.Errors.Add(error);
    }
    /// <summary>
    /// Raise a warning
    /// </summary>
    public void Warning(string message)
    {
        System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError();
        error.ErrorText = message;
        error.IsWarning = true;
        this.Errors.Add(error);
    }
    /// <summary>
    /// Increase the indent
    /// </summary>
    public void PushIndent(string indent)
    {
        if ((indent == null))
        {
            throw new global::System.ArgumentNullException("indent");
        }
        this.currentIndentField = (this.currentIndentField + indent);
        this.indentLengths.Add(indent.Length);
    }
    /// <summary>
    /// Remove the last indent that was added with PushIndent
    /// </summary>
    public string PopIndent()
    {
        string returnValue = "";
        if ((this.indentLengths.Count > 0))
        {
            int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
            this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
            if ((indentLength > 0))
            {
                returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
            }
        }
        return returnValue;
    }
    /// <summary>
    /// Remove any indentation
    /// </summary>
    public void ClearIndent()
    {
        this.indentLengths.Clear();
        this.currentIndentField = "";
    }
#endregion
#region ToString Helpers
    /// <summary>
    /// Utility class to produce culture-oriented representation of an object as a string.
    /// </summary>
    public class ToStringInstanceHelper
    {
        private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
        /// <summary>
        /// Gets or sets format provider to be used by ToStringWithCulture method.
        /// </summary>
        public System.IFormatProvider FormatProvider
        {
            get => this.formatProviderField;
            set
            {
                if ((value != null))
                {
                    this.formatProviderField  = value;
                }
            }
        }
        /// <summary>
        /// This is called from the compile/run appdomain to convert objects within an expression block to a string
        /// </summary>
        public string ToStringWithCulture(object objectToConvert)
        {
            if ((objectToConvert == null))
            {
                throw new global::System.ArgumentNullException("objectToConvert");
            }
            System.Type t = objectToConvert.GetType();
            System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                        typeof(System.IFormatProvider)});
            if ((method == null))
            {
                return objectToConvert.ToString();
            }
            else
            {
                return ((string)(method.Invoke(objectToConvert, new object[] {
                            this.formatProviderField })));
            }
        }
    }
    private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
    /// <summary>
    /// Helper to produce culture-oriented representation of an object as a string
    /// </summary>
    public ToStringInstanceHelper ToStringHelper => this.toStringHelperField;

#endregion
}

/// <summary>
/// Service making names within a scope unique. Initialize a new instance for every scope.
/// </summary>
internal sealed class UniqueIdentifierService
{
    // This is the list of keywords we check against when creating parameter names from property. 
    // If a name matches this keyword we prefix it.
    private static readonly string[] Keywords = new string[] {"class", "event"};

    /// <summary>
    /// Hash set to detect identifier collision.
    /// </summary>
    private readonly HashSet<string> knownIdentifiers;

    /// <summary>
    /// Constructs a <see cref="UniqueIdentifierService"/>.
    /// </summary>
    /// <param name="caseSensitive">true if the language we are generating the code for is case sensitive, false otherwise.</param>
    internal UniqueIdentifierService(bool caseSensitive)
    {
        this.knownIdentifiers = new HashSet<string>(caseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Constructs a <see cref="UniqueIdentifierService"/>.
    /// </summary>
    /// <param name="identifiers">identifiers used to detect collision.</param>
    /// <param name="caseSensitive">true if the language we are generating the code for is case sensitive, false otherwise.</param>
    internal UniqueIdentifierService(IEnumerable<string> identifiers, bool caseSensitive)
    {
        this.knownIdentifiers = new HashSet<string>(identifiers ?? Enumerable.Empty<string>(), caseSensitive ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Given an identifier, makes it unique within the scope by adding
    /// a suffix (1, 2, 3, ...), and returns the adjusted identifier.
    /// </summary>
    /// <param name="identifier">Identifier. Must not be null or empty.</param>
    /// <returns>Identifier adjusted to be unique within the scope.</returns>
    internal string GetUniqueIdentifier(string identifier)
    {
        Debug.Assert(!string.IsNullOrEmpty(identifier), "identifier is null or empty");

        // find a unique name by adding suffix as necessary
        int numberOfConflicts = 0;
        string uniqueIdentifier = identifier;
        while (this.knownIdentifiers.Contains(uniqueIdentifier))
        {
            ++numberOfConflicts;
            uniqueIdentifier = identifier + numberOfConflicts.ToString(CultureInfo.InvariantCulture);
        }

        // remember the identifier in this scope
        Debug.Assert(!this.knownIdentifiers.Contains(uniqueIdentifier), "we just made it unique");
        this.knownIdentifiers.Add(uniqueIdentifier);

        return uniqueIdentifier;
    }

    /// <summary>
    /// Fix up the given parameter name and make it unique.
    /// </summary>
    /// <param name="name">Parameter name.</param>
    /// <returns>Fixed parameter name.</returns>
    internal string GetUniqueParameterName(string name)
    {
        name = Utils.CamelCase(name);
        
        // FxCop consider 'iD' as violation, we will change any property that is 'id'(case insensitive) to 'ID'
        if (StringComparer.OrdinalIgnoreCase.Equals(name, "id"))
        {
            name = "ID";
        }

        return this.GetUniqueIdentifier(name);
    }
}

/// <summary>
/// Utility class.
/// </summary>    
internal static class Utils
{
    /// <summary>
    /// Serializes the xml element to a string.
    /// </summary>
    /// <param name="xml">The xml element to serialize.</param>
    /// <returns>The string representation of the xml.</returns>
    internal static string SerializeToString(XElement xml)
    {
        // because comment nodes can contain special characters that are hard to embed in VisualBasic, remove them here
        xml.DescendantNodes().OfType<XComment>().Remove();

        var stringBuilder = new StringBuilder();
        using (var writer = XmlWriter.Create(
            stringBuilder,
            new XmlWriterSettings
            {
                OmitXmlDeclaration = true,
                NewLineHandling = NewLineHandling.Replace,
                Indent = true,
            }))
        {
            xml.WriteTo(writer);
        }

        return stringBuilder.ToString();
    }

    /// <summary>
    /// Changes the text to use camel case, which lower case for the first character.
    /// </summary>
    /// <param name="text">Text to convert.</param>
    /// <returns>The converted text in camel case</returns>
    internal static string CamelCase(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return text;
        }

        if (text.Length == 1)
        {
            return text[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant();
        }

        return text[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant() + text.Substring(1);
    }

    /// <summary>
    /// Changes the text to use pascal case, which upper case for the first character.
    /// </summary>
    /// <param name="text">Text to convert.</param>
    /// <returns>The converted text in pascal case</returns>
    internal static string PascalCase(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return text;
        }

        if (text.Length == 1)
        {
            return text[0].ToString(CultureInfo.InvariantCulture).ToUpperInvariant();
        }

        return text[0].ToString(CultureInfo.InvariantCulture).ToUpperInvariant() + text.Substring(1);
    }

    /// <summary>
    /// Gets the clr type name from the give type reference.
    /// </summary>
    /// <param name="edmTypeReference">The type reference in question.</param>
    /// <param name="useDataServiceCollection">true to use the DataServicCollection type for entity collections and the ObservableCollection type for non-entity collections,
    /// false to use Collection for collections.</param>
    /// <param name="clientTemplate">ODataClientTemplate instance that call this method.</param>
    /// <param name="context">CodeGenerationContext instance in the clientTemplate.</param>
    /// <param name="addNullableTemplate">This flag indicates whether to return the type name in nullable format</param>
    /// <param name="needGlobalPrefix">The flag indicates whether the namespace need to be added by global prefix</param>
    /// <param name="isOperationParameter">This flag indicates whether the edmTypeReference is for an operation parameter</param>
    /// <returns>The clr type name of the type reference.</returns>
    internal static string GetClrTypeName(IEdmTypeReference edmTypeReference, bool useDataServiceCollection, ODataClientTemplate clientTemplate, CodeGenerationContext context, bool addNullableTemplate = true, bool needGlobalPrefix = true, bool isOperationParameter = false, bool isEntitySingleType = false)
    {
        string clrTypeName = null;
        IEdmType edmType = edmTypeReference.Definition;
        if (edmType is IEdmPrimitiveType edmPrimitiveType)
        {
            clrTypeName = Utils.GetClrTypeName(edmPrimitiveType, clientTemplate);
            if (edmTypeReference.IsNullable && !clientTemplate.ClrReferenceTypes.Contains(edmPrimitiveType.PrimitiveKind) && addNullableTemplate)
            {
                clrTypeName = string.Format(clientTemplate.SystemNullableStructureTemplate, clrTypeName);
            }
        }
        else
        {
            if (edmType is IEdmComplexType edmComplexType)
            {
                clrTypeName = context.GetPrefixedFullName(edmComplexType,
                    context.EnableNamingAlias ? clientTemplate.GetFixedName(Customization.CustomizeNaming(edmComplexType.Name)) : clientTemplate.GetFixedName(edmComplexType.Name), clientTemplate);
            }
            else
            {
                if (edmType is IEdmEnumType edmEnumType)
                {
                    clrTypeName = context.GetPrefixedFullName(edmEnumType,
                        context.EnableNamingAlias ? clientTemplate.GetFixedName(Customization.CustomizeNaming(edmEnumType.Name)) : clientTemplate.GetFixedName(edmEnumType.Name), clientTemplate, needGlobalPrefix);
                    if (edmTypeReference.IsNullable && addNullableTemplate)
                    {
                        clrTypeName = string.Format(clientTemplate.SystemNullableStructureTemplate, clrTypeName);
                    }
                }
                else 
                {
                    if (edmType is IEdmEntityType edmEntityType)
                    {
                        clrTypeName = context.GetPrefixedFullName(edmEntityType,
                            context.EnableNamingAlias
                                ? clientTemplate.GetFixedName(Customization.CustomizeNaming(edmEntityType.Name) + (isEntitySingleType ? clientTemplate.SingleSuffix : string.Empty))
                                : clientTemplate.GetFixedName(edmEntityType.Name + (isEntitySingleType ? clientTemplate.SingleSuffix : string.Empty)),
                        clientTemplate);
                    }
                    else
                    {
                        if (edmType is IEdmCollectionType edmCollectionType)
                        {
                            IEdmTypeReference elementTypeReference = edmCollectionType.ElementType;
                            if (elementTypeReference.Definition is IEdmPrimitiveType primitiveElementType)
                            {
                                clrTypeName = Utils.GetClrTypeName(primitiveElementType, clientTemplate);
                            }
                            else
                            {
                                IEdmSchemaElement schemaElement = (IEdmSchemaElement)elementTypeReference.Definition;
                                clrTypeName = context.GetPrefixedFullName(schemaElement,
                                    context.EnableNamingAlias ? clientTemplate.GetFixedName(Customization.CustomizeNaming(schemaElement.Name)) : clientTemplate.GetFixedName(schemaElement.Name), clientTemplate);
                            }

                            string collectionTypeName = isOperationParameter
                                ? clientTemplate.ICollectionOfTStructureTemplate
                                : (useDataServiceCollection
                                    ? (elementTypeReference.TypeKind() == EdmTypeKind.Entity
                                        ? clientTemplate.DataServiceCollectionStructureTemplate
                                        : clientTemplate.ObservableCollectionStructureTemplate)
                                    : clientTemplate.ObjectModelCollectionStructureTemplate);

                            clrTypeName = string.Format(collectionTypeName, clrTypeName);
                        }
                        else
                        {
                            if (edmType is IEdmTypeDefinition edmTypeDefinition)
                            {
                                if (edmTypeDefinition is IEdmSchemaElement schemaElement)
                                {
                                    clrTypeName = context.GetPrefixedFullName(schemaElement,
                                        context.EnableNamingAlias ? clientTemplate.GetFixedName(Customization.CustomizeNaming(schemaElement.Name)) : clientTemplate.GetFixedName(schemaElement.Name), clientTemplate);
                                }
                                else
                                {
                                    throw new NotSupportedException("Unknown edm-type.");
                                }
                            }
                            else
                            {
                                throw new NotSupportedException("Unknown edm-type.");
                            }

                        }
                    }
                }
            }
        }

        return clrTypeName;
    }

    /// <summary>
    /// Gets the value expression to initualize the property with.
    /// </summary>
    /// <param name="property">The property in question.</param>
    /// <param name="useDataServiceCollection">true to use the DataServicCollection type for entity collections and the ObservableCollection type for non-entity collections,
    /// false to use Collection for collections.</param>
    /// <param name="clientTemplate">ODataClientTemplate instance that call this method.</param>
    /// <param name="context">CodeGenerationContext instance in the clientTemplate.</param>
    /// <returns>The value expression to initualize the property with.</returns>
    internal static string GetPropertyInitializationValue(IEdmProperty property, bool useDataServiceCollection, ODataClientTemplate clientTemplate, CodeGenerationContext context)
    {
        IEdmTypeReference edmTypeReference = property.Type;
        IEdmCollectionTypeReference edmCollectionTypeReference = edmTypeReference as IEdmCollectionTypeReference;
        if (edmCollectionTypeReference == null)
        {
            if (property is IEdmStructuralProperty structuredProperty)
            {
                bool isCSharpTemplate = clientTemplate is ODataClientCSharpTemplate;
                string valueClrType = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context);
                if (!string.IsNullOrEmpty(structuredProperty.DefaultValueString))
                {
                    string defaultValue = structuredProperty.DefaultValueString;
                    if (edmTypeReference.Definition.TypeKind == EdmTypeKind.Enum)
                    {
                        var enumValues = defaultValue.Split(',');
                        string fullEnumTypeName = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context);
                        string enumTypeName = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context, false, false);
                        List<string> customizedEnumValues = new List<string>();
                        foreach(var enumValue in enumValues)
                        {
                            string currentEnumValue = enumValue.Trim();
                            int indexFirst = currentEnumValue.IndexOf('\'') + 1;
                            int indexLast = currentEnumValue.LastIndexOf('\'');
                            if (indexFirst > 0 && indexLast > indexFirst)
                            {
                                currentEnumValue = currentEnumValue.Substring(indexFirst, indexLast - indexFirst);
                            }

                            var customizedEnumValue = context.EnableNamingAlias ? Customization.CustomizeNaming(currentEnumValue) : currentEnumValue;
                            if (isCSharpTemplate)
                            {
                                currentEnumValue = "(" + fullEnumTypeName + ")" + clientTemplate.EnumTypeName + ".Parse(" + clientTemplate.SystemTypeTypeName + ".GetType(\"" + enumTypeName + "\"), \"" + customizedEnumValue  + "\")";
                            }
                            else
                            {
                                currentEnumValue = clientTemplate.EnumTypeName + ".Parse(" + clientTemplate.SystemTypeTypeName + ".GetType(\"" + enumTypeName + "\"), \"" + currentEnumValue  + "\")";
                            }
                            customizedEnumValues.Add(currentEnumValue);
                        }
                        if (isCSharpTemplate)
                        {
                            return string.Join(" | ", customizedEnumValues);
                        }
                        else
                        {
                            return string.Join(" Or ", customizedEnumValues); 
                        }
                    }

                    if (valueClrType.Equals(clientTemplate.StringTypeName))
                    {
                        defaultValue = "\"" + defaultValue + "\"";
                    }
                    else if (valueClrType.Equals(clientTemplate.BooleanTypeName))
                    {
                        // EDMX specifies boolean defaults with capital letter, C# needs this string to be lower case.
                        if (isCSharpTemplate)
                            defaultValue = defaultValue.ToLower();
                    }
                    else if (valueClrType.Equals(clientTemplate.BinaryTypeName))
                    {
                        defaultValue = "System.Text.Encoding.UTF8.GetBytes(\"" + defaultValue + "\")";
                    }
                    else if (valueClrType.Equals(clientTemplate.SingleTypeName))
                    {
                        if (isCSharpTemplate)
                        {
                            defaultValue = defaultValue.EndsWith("f", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "f";
                        }
                        else
                        {
                            defaultValue = defaultValue.EndsWith("f", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "F";
                        }
                    }
                    else if (valueClrType.Equals(clientTemplate.DecimalTypeName))
                    {
                        if (isCSharpTemplate)
                        {
                            // decimal in C# must be initialized with 'm' at the end, like Decimal dec = 3.00m
                            defaultValue = defaultValue.EndsWith("m", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "m";
                        }
                        else
                        {
                            // decimal in VB must be initialized with 'D' at the end, like Decimal dec = 3.00D
                            defaultValue = defaultValue.ToLower().Replace("m", "D");
                            defaultValue = defaultValue.EndsWith("D", StringComparison.OrdinalIgnoreCase) ? defaultValue : defaultValue + "D";
                        }
                    }
                    else if (valueClrType.Equals(clientTemplate.GuidTypeName)
                        | valueClrType.Equals(clientTemplate.DateTimeOffsetTypeName)
                        | valueClrType.Equals(clientTemplate.DateTypeName)
                        | valueClrType.Equals(clientTemplate.TimeOfDayTypeName))
                    {
                        defaultValue = valueClrType + ".Parse(\"" + defaultValue + "\")";
                    }
                    else if (valueClrType.Equals(clientTemplate.DurationTypeName))
                    {
                        defaultValue = clientTemplate.XmlConvertClassName + ".ToTimeSpan(\"" + defaultValue + "\")";
                    }
                    else if (valueClrType.Contains("Microsoft.Spatial"))
                    {
                        defaultValue = string.Format(clientTemplate.GeoTypeInitializePattern, valueClrType, defaultValue);
                    }
                    //else
                    //{
                    //    Debugger.Launch();
                    //    Debugger.Break();
                    //}
                    return defaultValue;
                }
                else
                {
                    // doesn't have a default value 

                    // We can't pass "null" complex types to the service, they must always have a value, so add one by default to
                    // prevent all that null checking... but they must be nullable to support other conventions...
                    // for almost all intents they are mutable structs, which we are taught are "evil" so that is why they are not actual structs.
                    if (isCSharpTemplate)
                    {
                        if(structuredProperty.Type.IsComplex())
                        {
                            // known dodgy types, skip this
                            var skipTypes = new[]
                            {
                                "GSO.Care.HttpContent"
                            };

                            string typeFullName = structuredProperty.Type.FullName();
                            if (skipTypes.Contains(typeFullName))
                            {
                                return null;
                            }
                            else if (structuredProperty.Type.FullName().EndsWith("GSO.Care.Interval"))
                            {
                                // known common complex type
                                return "new GSO.Care.Interval { Type = IntervalType.None }";
                            }
                            else
                            {
                                return $"new {structuredProperty.Type.FullName()}()";
                            }
                        }
                    }

                    return null;
                }
            }
            else
            {
                // only structured property has default value
                return null;
            }
        }
        else
        {
            string constructorParameters;
            if (edmCollectionTypeReference.ElementType().IsEntity() && useDataServiceCollection)
            {
                constructorParameters = clientTemplate.DataServiceCollectionConstructorParameters;
            }
            else
            {
                constructorParameters = "()";
            }

            string clrTypeName = GetClrTypeName(edmTypeReference, useDataServiceCollection, clientTemplate, context);
            return clientTemplate.NewModifier + clrTypeName + constructorParameters;
        }
    }
        
    /// <summary>
    /// Gets the clr type name from the give Edm primitive type.
    /// </summary>
    /// <param name="edmPrimitiveType">The Edm primitive type in question.</param>
    /// <param name="clientTemplate">ODataClientTemplate instance that call this method.</param>
    /// <returns>The clr type name of the Edm primitive type.</returns>
    internal static string GetClrTypeName(IEdmPrimitiveType edmPrimitiveType, ODataClientTemplate clientTemplate)
    {
        EdmPrimitiveTypeKind kind = edmPrimitiveType.PrimitiveKind;

        string type="UNKNOWN";
        if (kind==EdmPrimitiveTypeKind.Int32)
        {
            type= clientTemplate.Int32TypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.String)
        {
            type= clientTemplate.StringTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Binary)
        {
            type= clientTemplate.BinaryTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Decimal)
        {
            type= clientTemplate.DecimalTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Int16)
        { 
            type= clientTemplate.Int16TypeName; 
        }
        else if(kind==EdmPrimitiveTypeKind.Single)
        {    
            type= clientTemplate.SingleTypeName;
        }
        else if (kind==EdmPrimitiveTypeKind.Boolean)
        {  
            type= clientTemplate.BooleanTypeName; 
        }
        else if (kind== EdmPrimitiveTypeKind.Double)
        {
            type= clientTemplate.DoubleTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Guid)
        {
            type= clientTemplate.GuidTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Byte)
        {
            type= clientTemplate.ByteTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Int64)
        {
            type= clientTemplate.Int64TypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.SByte)
        {
            type= clientTemplate.SByteTypeName;
        }
        else if (kind == EdmPrimitiveTypeKind.Stream)
        {
            type= clientTemplate.DataServiceStreamLinkTypeName;
        }        
        else if (kind== EdmPrimitiveTypeKind.Geography)
        {
            type= clientTemplate.GeographyTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyPoint)
        {
            type= clientTemplate.GeographyPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyLineString)
        {
            type= clientTemplate.GeographyLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyPolygon)
        {
            type= clientTemplate.GeographyPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyCollection)
        {
            type= clientTemplate.GeographyCollectionTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyMultiPolygon)
        {
            type= clientTemplate.GeographyMultiPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyMultiLineString)
        {
            type= clientTemplate.GeographyMultiLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeographyMultiPoint)
        {
            type= clientTemplate.GeographyMultiPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Geometry)
        {
            type= clientTemplate.GeometryTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryPoint)
        {
            type= clientTemplate.GeometryPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryLineString)
        {
            type= clientTemplate.GeometryLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryPolygon)
        {
            type= clientTemplate.GeometryPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryCollection)
        {
            type= clientTemplate.GeometryCollectionTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryMultiPolygon)
        {
            type= clientTemplate.GeometryMultiPolygonTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryMultiLineString)
        {
            type= clientTemplate.GeometryMultiLineStringTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.GeometryMultiPoint)
        {
            type= clientTemplate.GeometryMultiPointTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.DateTimeOffset)
        {
            type= clientTemplate.DateTimeOffsetTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Duration)
        {
            type= clientTemplate.DurationTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.Date)
        {
            type= clientTemplate.DateTypeName;
        }
        else if (kind== EdmPrimitiveTypeKind.TimeOfDay)
        {
            type= clientTemplate.TimeOfDayTypeName;
        }
        else
        {
            throw new Exception("Type "+kind.ToString()+" is unrecognized");
        }

        return type;
    }
}

public sealed class ODataClientCSharpTemplate : ODataClientTemplate
{
    /// <summary>
    /// Creates an instance of the ODataClientTemplate.
    /// </summary>
    /// <param name="context">The code generation context.</param>
    public ODataClientCSharpTemplate(CodeGenerationContext context)
        : base(context)
    {
    }

    internal override string GlobalPrefix => "global::";
    internal override string SystemTypeTypeName => "global::System.Type";
    internal override string AbstractModifier => " abstract";
    internal override string DataServiceActionQueryTypeName => "global::Microsoft.OData.Client.DataServiceActionQuery";
    internal override string DataServiceActionQuerySingleOfTStructureTemplate => "global::Microsoft.OData.Client.DataServiceActionQuerySingle<{0}>";
    internal override string DataServiceActionQueryOfTStructureTemplate => "global::Microsoft.OData.Client.DataServiceActionQuery<{0}>";
    internal override string NotifyPropertyChangedModifier => "global::System.ComponentModel.INotifyPropertyChanged, global::System.ComponentModel.IRevertibleChangeTracking, global::System.Runtime.Serialization.IDeserializationCallback, IHasChanged";
    internal override string ClassInheritMarker => " : ";
    internal override string ParameterSeparator => ", \r\n                    ";
    internal override string KeyParameterSeparator => ", \r\n            ";
    internal override string KeyDictionaryItemSeparator => ", \r\n                ";
    internal override string SystemNullableStructureTemplate => "global::System.Nullable<{0}>";
    internal override string ICollectionOfTStructureTemplate => "global::System.Collections.Generic.ICollection<{0}>";
    internal override string DataServiceCollectionStructureTemplate => "global::Microsoft.OData.Client.DataServiceCollection<{0}>";
    internal override string DataServiceQueryStructureTemplate => "global::Microsoft.OData.Client.DataServiceQuery<{0}>";
    internal override string DataServiceQuerySingleStructureTemplate => "global::Microsoft.OData.Client.DataServiceQuerySingle<{0}>";
    internal override string ObservableCollectionStructureTemplate => "global::System.Collections.ObjectModel.ObservableCollection<{0}>";
    internal override string ObjectModelCollectionStructureTemplate => "global::System.Collections.ObjectModel.Collection<{0}>";
    internal override string DataServiceCollectionConstructorParameters => "(null, global::Microsoft.OData.Client.TrackingMode.None)";
    internal override string NewModifier => "new ";
    internal override string GeoTypeInitializePattern => "global::Microsoft.Spatial.SpatialImplementation.CurrentImplementation.CreateWellKnownTextSqlFormatter(false).Read<{0}>(new global::System.IO.StringReader(\"{1}\"))";
    internal override string Int32TypeName => "int";
    internal override string ObjectTypeName => "object";
    internal override string StringTypeName => "string";
    internal override string BinaryTypeName => "byte[]";
    internal override string DecimalTypeName => "decimal";
    internal override string Int16TypeName => "short";
    internal override string SingleTypeName => "float";
    internal override string BooleanTypeName => "bool";
    internal override string DoubleTypeName => "double";
    internal override string GuidTypeName => "global::System.Guid";
    internal override string ByteTypeName => "byte";
    internal override string Int64TypeName => "long";
    internal override string SByteTypeName => "sbyte";
    internal override string DataServiceStreamLinkTypeName => "global::Microsoft.OData.Client.DataServiceStreamLink";
    internal override string GeographyTypeName => "global::Microsoft.Spatial.Geography";
    internal override string GeographyPointTypeName => "global::Microsoft.Spatial.GeographyPoint";
    internal override string GeographyLineStringTypeName => "global::Microsoft.Spatial.GeographyLineString";
    internal override string GeographyPolygonTypeName => "global::Microsoft.Spatial.GeographyPolygon";
    internal override string GeographyCollectionTypeName => "global::Microsoft.Spatial.GeographyCollection";
    internal override string GeographyMultiPolygonTypeName => "global::Microsoft.Spatial.GeographyMultiPolygon";
    internal override string GeographyMultiLineStringTypeName => "global::Microsoft.Spatial.GeographyMultiLineString";
    internal override string GeographyMultiPointTypeName => "global::Microsoft.Spatial.GeographyMultiPoint";
    internal override string GeometryTypeName => "global::Microsoft.Spatial.Geometry";
    internal override string GeometryPointTypeName => "global::Microsoft.Spatial.GeometryPoint";
    internal override string GeometryLineStringTypeName => "global::Microsoft.Spatial.GeometryLineString";
    internal override string GeometryPolygonTypeName => "global::Microsoft.Spatial.GeometryPolygon";
    internal override string GeometryCollectionTypeName => "global::Microsoft.Spatial.GeometryCollection";
    internal override string GeometryMultiPolygonTypeName => "global::Microsoft.Spatial.GeometryMultiPolygon";
    internal override string GeometryMultiLineStringTypeName => "global::Microsoft.Spatial.GeometryMultiLineString";
    internal override string GeometryMultiPointTypeName => "global::Microsoft.Spatial.GeometryMultiPoint";
    internal override string DateTypeName => "global::Microsoft.OData.Edm.Date";
    internal override string DateTimeOffsetTypeName => "global::System.DateTimeOffset";
    internal override string DurationTypeName => "global::System.TimeSpan";
    internal override string TimeOfDayTypeName => "global::Microsoft.OData.Edm.TimeOfDay";
    internal override string XmlConvertClassName => "global::System.Xml.XmlConvert";
    internal override string EnumTypeName => "global::System.Enum";
    internal override string DictionaryTypeName => "global::System.Collections.Generic.Dictionary<{0}, {1}>";
    internal override string FixPattern => "@{0}";
    internal override string EnumUnderlyingTypeMarker => " : ";
    internal override string ConstantExpressionConstructorWithType => "global::System.Linq.Expressions.Expression.Constant({0}, typeof({1}))";
    internal override string TypeofFormatter => "typeof({0})";
    internal override string UriOperationParameterConstructor => "new global::Microsoft.OData.Client.UriOperationParameter(\"{0}\", {1})";
    internal override string UriEntityOperationParameterConstructor => "new global::Microsoft.OData.Client.UriEntityOperationParameter(\"{0}\", {1}, {2})";
    internal override string BodyOperationParameterConstructor => "new global::Microsoft.OData.Client.BodyOperationParameter(\"{0}\", {1})";
    internal override string DictionaryConstructor => $"new {DictionaryTypeName}()";
    internal override string BaseEntityType => " : global::Microsoft.OData.Client.BaseEntityType";
    internal override string OverloadsModifier => "new ";
    internal override string ODataVersion => "global::Microsoft.OData.ODataVersion.V4";
    internal override string ParameterDeclarationTemplate => "{0} {1}";
    internal override string DictionaryItemConstructor => "{{ {0}, {1} }}";

    internal override HashSet<string> LanguageKeywords { get {
            if (CSharpKeywords == null)
            {
                CSharpKeywords = new HashSet<string>(StringComparer.Ordinal)
    {
        "abstract", "as", "base", "byte", "bool", "break", "case", "catch", "char", "checked", "class", "const", "continue",
        "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "for",
        "foreach", "finally", "fixed", "float", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
        "long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public",
        "readonly", "ref", "return", "sbyte", "sealed", "string", "short", "sizeof", "stackalloc", "static", "struct", "switch",
        "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "volatile",
        "void", "while"
    };
            }
            return CSharpKeywords;
        } }
    private HashSet<string> CSharpKeywords;

    /// <summary>
    /// Write out the <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> for a member that declares the name of this tool and the current version.
    /// If this is a debug build, the name of the calling method that executed this method will be injected as the Tool to assist with debugging and extension development
    /// </summary>
    /// <param name="member">Name of the method that called into this method</param>
    /// <remarks>Member name is only visible during debugging</remarks>
    internal override void WriteGeneratedCodeAttribute([System.Runtime.CompilerServices.CallerMemberName] string member = null)
    {
        this.Write("        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"");
#if DEBUG
        this.Write(member);
#else
this.Write("Microsoft.OData.Client.Design.T4");
#endif

        this.Write("\",\"");
        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));
        this.Write("\")]\r\n");
    }

    internal override void WriteFileHeader()
    {

        this.Write("//------------------------------------------------------------------------------\r" +
                "\n// <auto-generated>\r\n//     This code was generated by a tool.\r\n//     Runtime " +
                "Version:");

        this.Write(this.ToStringHelper.ToStringWithCulture(Environment.Version));

        this.Write("\r\n//\r\n//     Changes to this file may cause incorrect behavior and will be lost i" +
                "f\r\n//     the code is regenerated.\r\n// </auto-generated>\r\n//--------------------" +
                "----------------------------------------------------------\r\n\r\n// Generation date" +
                ": ");

        this.Write(this.ToStringHelper.ToStringWithCulture(DateTime.Now.ToString(global::System.Globalization.CultureInfo.CurrentCulture)));

        this.Write("\r\n");

        this.WriteLine("using System;");
        if (this.context.UseAsyncDataServiceCollection)
        {
            this.WriteLine("using System.Linq;");
        }

    }

    internal override void WriteNamespaceStart(string fullNamespace)
    {

        this.Write("namespace ");

        this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

        this.Write("\r\n{\r\n");


    }

    internal override void WriteClassStartForEntityContainer(string originalContainerName, string containerName, string fixedContainerName)
    {

        this.Write("    /// <summary>\r\n    /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(containerName));

        this.Write(" in the schema.\r\n    /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("    [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalContainerName));

            this.Write("\")]\r\n");


        }

        this.Write("    public partial class ");

        this.Write(this.ToStringHelper.ToStringWithCulture(fixedContainerName));

        this.Write(" : global::Microsoft.OData.Client.DataServiceContext\r\n    {\r\n");


    }

    internal override void WriteMethodStartForEntityContainerConstructor(string containerName, string fixedContainerName)
    {

        this.Write("        /// <summary>\r\n        /// Initialize a new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(containerName));

        this.Write(" object.\r\n        /// </summary>\r\n        [global::System.CodeDom.Compiler.Genera" +
                "tedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(fixedContainerName));

        this.Write("(global::System.Uri serviceRoot) : \r\n                base(serviceRoot, global::Mi" +
                "crosoft.OData.Client.ODataProtocolVersion.V4)\r\n        {\r\n");


    }

    internal override void WriteKeyAsSegmentUrlConvention()
    {

        this.Write("            this.UrlKeyDelimiter = global::Microsoft.OData.Client.DataServiceUrlK" +
                "eyDelimiter.Slash;\r\n");


    }

    internal override void WriteInitializeResolveName()
    {

        this.Write("            this.ResolveName = new global::System.Func<global::System.Type, strin" +
                "g>(this.ResolveNameFromType);\r\n");


    }

    internal override void WriteInitializeResolveType()
    {

        this.Write("            this.ResolveType = new global::System.Func<string, global::System.Typ" +
                "e>(this.ResolveTypeFromName);\r\n");


    }

    internal override void WriteClassEndForEntityContainerConstructor()
    {

        this.Write("            this.OnContextCreated();\r\n            this.Format.LoadServiceModel = " +
                "GeneratedEdmModel.GetInstance;\r\n            this.Format.UseJson();\r\n        }\r\n " +
                "       partial void OnContextCreated();\r\n");


    }

    internal override void WriteMethodStartForResolveTypeFromName()
    {

        this.Write(@"        /// <summary>
/// Since the namespace configured for this service reference
/// in Visual Studio is different from the one indicated in the
/// server schema, use type-mappers to map between the two.
/// </summary>
[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n        protected global::System.Type ResolveTypeFromName(string typeName)\r\n" +
                "        {\r\n");


    }

    internal override void WriteResolveNamespace(string typeName, string fullNamespace, string languageDependentNamespace)
    {

        this.Write("            ");

        this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

        this.Write("resolvedType = this.DefaultResolveType(typeName, \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

        this.Write("\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(languageDependentNamespace));

        this.Write("\");\r\n            if ((resolvedType != null))\r\n            {\r\n                retu" +
                "rn resolvedType;\r\n            }\r\n");


    }

    internal override void WriteMethodEndForResolveTypeFromName()
    {

        this.Write("            return null;\r\n        }\r\n");


    }

    internal override void WritePropertyRootNamespace(string containerName, string fullNamespace)
    {

    }

    internal override void WriteMethodStartForResolveNameFromType(string containerName, string fullNamespace)
    {

        this.Write(@"        /// <summary>
/// Since the namespace configured for this service reference
/// in Visual Studio is different from the one indicated in the
/// server schema, use type-mappers to map between the two.
/// </summary>
[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n        protected string ResolveNameFromType(global::System.Type clientType)" +
                "\r\n        {\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write(@"            global::Microsoft.OData.Client.OriginalNameAttribute originalNameAttribute = (global::Microsoft.OData.Client.OriginalNameAttribute)global::System.Linq.Enumerable.SingleOrDefault(global::Microsoft.OData.Client.Utility.GetCustomAttributes(clientType, typeof(global::Microsoft.OData.Client.OriginalNameAttribute), true));
");


        }
    }

    internal override void WriteResolveType(string fullNamespace, string languageDependentNamespace)
    {

        this.Write("            if (clientType.Namespace.Equals(\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(languageDependentNamespace));

        this.Write("\", global::System.StringComparison.Ordinal))\r\n            {\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("                if (originalNameAttribute != null)\r\n                {\r\n          " +
                    "          return string.Concat(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

            this.Write(".\", originalNameAttribute.OriginalName);\r\n                }\r\n");


        }

        this.Write("                return string.Concat(\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

        this.Write(".\", clientType.Name);\r\n            }\r\n");


    }

    internal override void WriteMethodEndForResolveNameFromType(bool modelHasInheritance)
    {
        if (this.context.EnableNamingAlias && modelHasInheritance)
        {

            this.Write("            if (originalNameAttribute != null)\r\n            {\r\n                re" +
                    "turn clientType.Namespace + \".\" + originalNameAttribute.OriginalName;\r\n         " +
                    "   }\r\n");


        }

        this.Write("            return ");

        this.Write(this.ToStringHelper.ToStringWithCulture(modelHasInheritance ? "clientType.FullName" : "null"));

        this.Write(";\r\n        }\r\n");


    }

    internal override void WriteConstructorForSingleType(string singleTypeName, string baseTypeName)
    {

        this.Write("        /// <summary>\r\n        /// Initialize a new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

        this.Write(" object.\r\n        /// </summary>\r\n        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

        this.Write("(global::Microsoft.OData.Client.DataServiceContext context, string path)\r\n       " +
                "     : base(context, path) {}\r\n\r\n        /// <summary>\r\n        /// Initialize a" +
                " new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

        this.Write(" object.\r\n        /// </summary>\r\n        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

        this.Write("(global::Microsoft.OData.Client.DataServiceContext context, string path, bool isC" +
                "omposable)\r\n            : base(context, path, isComposable) {}\r\n\r\n        /// <s" +
                "ummary>\r\n        /// Initialize a new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

        this.Write(" object.\r\n        /// </summary>\r\n        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

        this.Write("(");

        this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

        this.Write(" query)\r\n            : base(query) {}\r\n\r\n");


    }

    internal override void WriteContextEntitySetProperty(string entitySetName, string entitySetFixedName, string originalEntitySetName, string entitySetElementTypeName, bool inContext)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n        [global::System.CodeDom.Compiler" +
                ".GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalEntitySetName));

            this.Write("\")]\r\n");


        }

        this.Write("        public global::Microsoft.OData.Client.DataServiceQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

        this.Write("> ");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetFixedName));

        this.Write("\r\n        {\r\n            get\r\n            {\r\n");


        if (!inContext)
        {

            this.Write("                if (!this.IsComposable)\r\n                {\r\n                    t" +
                    "hrow new global::System.NotSupportedException(\"The previous function is not comp" +
                    "osable.\");\r\n                }\r\n");


        }

        this.Write("                if ((this._");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

        this.Write(" == null))\r\n                {\r\n                    this._");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

        this.Write(" = ");

        this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "base" : "Context"));

        this.Write(".CreateQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

        this.Write(">(");

        this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "\"" + originalEntitySetName + "\"" : "GetPath(\"" + originalEntitySetName + "\")"));

        this.Write(");\r\n                }\r\n                return this._");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

        this.Write(";\r\n            }\r\n        }\r\n        [global::System.CodeDom.Compiler.GeneratedCo" +
                "deAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n        private global::Microsoft.OData.Client.DataServiceQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

        this.Write("> _");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

        this.Write(";\r\n");


    }

    internal override void WriteContextSingletonProperty(string singletonName, string singletonFixedName, string originalSingletonName, string singletonElementTypeName, bool inContext)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

        this.WriteLine(" in the schema.\r\n        /// </summary>");
        this.WriteGeneratedCodeAttribute();


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalSingletonName));

            this.Write("\")]\r\n");


        }

        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(singletonFixedName));

        this.Write("\r\n        {\r\n            get\r\n            {\r\n");


        if (!inContext)
        {

            this.Write("                if (!this.IsComposable)\r\n                {\r\n                    t" +
                    "hrow new global::System.NotSupportedException(\"The previous function is not comp" +
                    "osable.\");\r\n                }\r\n");


        }

        this.Write("                if ((this._");

        this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

        this.Write(" == null))\r\n                {\r\n                    this._");

        this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

        this.Write(" = new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

        this.Write("(");

        this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "this" : "this.Context"));

        this.Write(", ");

        this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "\"" + originalSingletonName + "\"" : "GetPath(\"" + originalSingletonName + "\")"));

        this.Write(");\r\n                }\r\n                return this._");

        this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

        this.Write(";\r\n            }\r\n        }\r\n        [global::System.CodeDom.Compiler.GeneratedCo" +
                "deAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n        private ");

        this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

        this.Write(" _");

        this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

        this.Write(";\r\n");


    }

    internal override void WriteContextAddToEntitySetMethod(string entitySetName, string originalEntitySetName, string typeName, string parameterName)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n        [global::System.CodeDom.Compiler" +
                ".GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n        public void AddTo");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

        this.Write("(");

        this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

        this.Write(")\r\n        {\r\n            this.AddObject(\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(originalEntitySetName));

        this.Write("\", ");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

        this.Write(");\r\n        }\r\n");


    }

    internal override void WriteGeneratedEdmModel(string escapedEdmxString)
    {

        string path = this.context.TempFilePath;

        if (!String.IsNullOrEmpty(path))
        {
            using (StreamWriter writer = new StreamWriter(path, true))
            {
                writer.WriteLine(escapedEdmxString);
            }
        }

        bool useTempFile = !String.IsNullOrEmpty(path) && System.IO.File.Exists(path);

        this.Write("        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData." +
                "Client.Design.T4\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n        private abstract class GeneratedEdmModel\r\n        {\r\n");


        if (this.context.ReferencesMap != null)
        {

            this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
                    "ata.Client.Design.T4\", \"");

            this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

            this.Write("\")]\r\n            private static global::System.Collections.Generic.Dictionary<str" +
                    "ing, string> ReferencesMap = new global::System.Collections.Generic.Dictionary<s" +
                    "tring, string>()\r\n                {\r\n");


            foreach (var reference in this.context.ReferencesMap)
            {

                this.Write("                    {@\"");

                this.Write(this.ToStringHelper.ToStringWithCulture(reference.Key.OriginalString.Replace("\"", "\"\"")));

                this.Write("\", @\"");

                this.Write(this.ToStringHelper.ToStringWithCulture(Utils.SerializeToString(reference.Value).Replace("\"", "\"\"")));

                this.Write("\"},\r\n");


            }

            this.Write("                };\r\n");


        }

        this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
                "ata.Client.Design.T4\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n            private static global::Microsoft.OData.Edm.IEdmModel ParsedModel" +
                " = LoadModelFromString();\r\n");


        if (useTempFile)
        {

            this.Write("   \r\n           [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsof" +
                    "t.OData.Client.Design.T4\", \"");

            this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

            this.Write("\")]\r\n           private const string filePath = @\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(path));

            this.Write("\";\r\n");


        }
        else
        {

            this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
                    "ata.Client.Design.T4\", \"");

            this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

            this.Write("\")]\r\n            private const string Edmx = @\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(escapedEdmxString));

            this.Write("\";\r\n");


        }

        this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
                "ata.Client.Design.T4\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n            public static global::Microsoft.OData.Edm.IEdmModel GetInstance(" +
                ")\r\n            {\r\n                return ParsedModel;\r\n            }\r\n");


        if (this.context.ReferencesMap != null)
        {

            this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
                    "ata.Client.Design.T4\", \"");

            this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

            this.Write(@""")]
    private static global::System.Xml.XmlReader getReferencedModelFromMap(global::System.Uri uri)
    {
        string referencedEdmx;
        if (ReferencesMap.TryGetValue(uri.OriginalString, out referencedEdmx))
        {
            return CreateXmlReader(referencedEdmx);
        }

        return null;
    }
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

            this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

            this.Write("\")]\r\n            private static global::Microsoft.OData.Edm.IEdmModel LoadModelFr" +
                    "omString()\r\n            {\r\n");


            if (useTempFile)
            {

                this.Write("   \r\n                global::System.Xml.XmlReader reader = CreateXmlReader();\r\n");


            }
            else
            {

                this.Write("                global::System.Xml.XmlReader reader = CreateXmlReader(Edmx);\r\n");


            }

            this.Write(@"                try
        {
            return global::Microsoft.OData.Edm.Csdl.CsdlReader.Parse(reader, getReferencedModelFromMap);
        }
        finally
        {
            ((global::System.IDisposable)(reader)).Dispose();
        }
    }
");


        }
        else
        {

            this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
                    "ata.Client.Design.T4\", \"");

            this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

            this.Write("\")]\r\n            private static global::Microsoft.OData.Edm.IEdmModel LoadModelFr" +
                    "omString()\r\n            {\r\n");


            if (useTempFile)
            {

                this.Write("   \r\n                global::System.Xml.XmlReader reader = CreateXmlReader();\r\n");


            }
            else
            {

                this.Write("                global::System.Xml.XmlReader reader = CreateXmlReader(Edmx);\r\n");


            }

            this.Write(@"                try
        {
            global::System.Collections.Generic.IEnumerable<global::Microsoft.OData.Edm.Validation.EdmError> errors;
            global::Microsoft.OData.Edm.IEdmModel edmModel;
                    
            if (!global::Microsoft.OData.Edm.Csdl.CsdlReader.TryParse(reader, ");

            this.Write(this.ToStringHelper.ToStringWithCulture(this.context.IgnoreUnexpectedElementsAndAttributes ? "true" : "false"));

            this.Write(@", out edmModel, out errors))
            {
                global::System.Text.StringBuilder errorMessages = new global::System.Text.StringBuilder();
                foreach (var error in errors)
                {
                    errorMessages.Append(error.ErrorMessage);
                    errorMessages.Append(""; "");
                }
                throw new global::System.InvalidOperationException(errorMessages.ToString());
            }

            return edmModel;
        }
        finally
        {
            ((global::System.IDisposable)(reader)).Dispose();
        }
    }
");


        }

        this.Write("            [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OD" +
                "ata.Client.Design.T4\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n            private static global::System.Xml.XmlReader CreateXmlReader(stri" +
                "ng edmxToParse)\r\n            {\r\n                return global::System.Xml.XmlRea" +
                "der.Create(new global::System.IO.StringReader(edmxToParse));\r\n            }\r\n");


        if (useTempFile)
        {

            this.Write("   \r\n                [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Mic" +
                    "rosoft.OData.Client.Design.T4\", \"");

            this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

            this.Write("\")]\r\n                private static global::System.Xml.XmlReader CreateXmlReader(" +
                    ")\r\n                {\r\n                    return global::System.Xml.XmlReader.Cr" +
                    "eate(new global::System.IO.StreamReader(filePath));\r\n                }\r\n");


        }

        this.Write("        }\r\n");


    }

    internal override void WriteClassEndForEntityContainer()
    {

        this.Write("    }\r\n");


    }

    internal override void WriteSummaryCommentForStructuredType(string typeName)
    {

        this.Write("    /// <summary>\r\n    /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

        this.Write(" in the schema.\r\n    /// </summary>\r\n");


    }

    internal override void WriteKeyPropertiesCommentAndAttribute(IEnumerable<string> keyProperties, string keyString)
    {

        this.Write("    /// <KeyProperties>\r\n");


        foreach (string key in keyProperties)
        {

            this.Write("    /// ");

            this.Write(this.ToStringHelper.ToStringWithCulture(key));

            this.Write("\r\n");


        }

        this.Write("    /// </KeyProperties>\r\n    [global::Microsoft.OData.Client.Key(\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(keyString));

        this.Write("\")]\r\n");


    }

    internal override void WriteEntityTypeAttribute()
    {

        this.Write("    [global::Microsoft.OData.Client.EntityType()]\r\n");


    }

    internal override void WriteEntitySetAttribute(string entitySetName)
    {

        this.Write("    [global::Microsoft.OData.Client.EntitySet(\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

        this.Write("\")]\r\n");


    }

    internal override void WriteEntityHasStreamAttribute()
    {

        this.Write("    [global::Microsoft.OData.Client.HasStream()]\r\n");


    }

    internal override void WriteClassStartForStructuredType(string abstractModifier, string typeName, string originalTypeName, string baseTypeName)
    {
        if (this.context.EnableNamingAlias)
        {
            this.Write("    [global::Microsoft.OData.Client.OriginalNameAttribute(\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(originalTypeName));
            this.Write("\")]\r\n");
        }

        this.Write("    public");
        this.Write(this.ToStringHelper.ToStringWithCulture(abstractModifier));
        this.Write(" partial class ");
        this.Write(this.ToStringHelper.ToStringWithCulture(typeName));
        this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));
        if (this.context.UseDataServiceCollection && baseTypeName.Contains("IRevertibleChangeTracking"))
            this.Write($", IHasChanged<{this.ToStringHelper.ToStringWithCulture(typeName)}>");
        this.Write("\r\n    {\r\n");

        if (this.context.UseDataServiceCollection && baseTypeName.Contains("IRevertibleChangeTracking"))
        {
            this.Write($@"        #region IHasChanged
        [System.Runtime.Serialization.IgnoreDataMember]
        [FormMetaData]
        ChangeTracker IHasChanged.Values {{ get => __Values; }}
        protected readonly ChangeTracker __Values;
        public bool HasChanged<TProperty>(global::System.Linq.Expressions.Expression<global::System.Func<{this.ToStringHelper.ToStringWithCulture(typeName)}, TProperty>> propertyExpression)
        {{
            var name = SDSS.ExpressionExtensions.MemberName(propertyExpression);
            return this.__Values.TryGetValue(name, out IValueTracker t) && t.IsChanged;
        }}
        public bool HasChanged(string propertyName)
        {{
            return this.__Values.TryGetValue(propertyName, out IValueTracker t) && t.IsChanged;
        }}
        #endregion IHasChanged

        public {this.ToStringHelper.ToStringWithCulture(typeName)}()
        {{
            __Values = new ChangeTracker(RaisePropertyChanged, SetChanged);
            Init();
        }}

        partial void Init();
");

        }
    }

    internal override void WriteSummaryCommentForStaticCreateMethod(string typeName)
    {

        this.Write("        /// <summary>\r\n        /// Create a new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

        this.Write(" object.\r\n        /// </summary>\r\n");


    }

    internal override void WriteParameterCommentForStaticCreateMethod(string parameterName, string propertyName)
    {

        this.Write("        /// <param name=\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

        this.Write("\">Initial value of ");

        this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

        this.Write(".</param>\r\n");


    }

    internal override void WriteDeclarationStartForStaticCreateMethod(string typeName, string fixedTypeName)
    {

        this.Write("        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData." +
                "Client.Design.T4\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

        this.Write("\")]\r\n        public static ");

        this.Write(this.ToStringHelper.ToStringWithCulture(fixedTypeName));

        this.Write(" Create");

        this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

        this.Write("(");


    }

    internal override void WriteParameterForStaticCreateMethod(string parameterTypeName, string parameterName, string parameterSeparater)
    {

        this.Write(this.ToStringHelper.ToStringWithCulture(parameterTypeName));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

        this.Write(this.ToStringHelper.ToStringWithCulture(parameterSeparater));


    }

    internal override void WriteDeclarationEndForStaticCreateMethod(string typeName, string instanceName)
    {

        this.Write(")\r\n        {\r\n            ");

        this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

        this.Write(" = new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

        this.Write("();\r\n");


    }

    internal override void WriteParameterNullCheckForStaticCreateMethod(string parameterName)
    {

        this.Write("            if ((");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

        this.Write(" == null))\r\n            {\r\n                throw new global::System.ArgumentNullE" +
                "xception(\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

        this.Write("\");\r\n            }\r\n");


    }

    internal override void WritePropertyValueAssignmentForStaticCreateMethod(string instanceName, string propertyName, string parameterName)
    {

        this.Write("            ");

        this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

        this.Write(".");

        this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

        this.Write(" = ");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

        this.Write(";\r\n");


    }

    internal override void WriteMethodEndForStaticCreateMethod(string instanceName)
    {

        this.Write("            return ");

        this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

        this.Write(";\r\n        }\r\n");


    }
    internal override void WritePropertyForStructuredType(string propertyType, string originalPropertyName, string propertyName, string fixedPropertyName, string privatePropertyName, string propertyInitializationValue, bool writeOnPropertyChanged, bool writeRequiredPropertyAttribute, int? maxPropertyDataLength, Microsoft.OData.Edm.EdmReferentialConstraint foreignKey, bool isComplexType)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for Property ");

        this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");

        this.WriteGeneratedCodeAttribute();

        if(writeRequiredPropertyAttribute)
        {
            this.Write("        [global::System.ComponentModel.DataAnnotations.RequiredAttribute(ErrorMessage = \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));
            this.Write(" is required.\")]\r\n");
        }
        if(maxPropertyDataLength.GetValueOrDefault() > 0)
        {
            this.Write("        [global::System.ComponentModel.DataAnnotations.MaxLengthAttribute(" + maxPropertyDataLength.Value + ", ErrorMessage = \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));
            this.Write(" must be less than " + maxPropertyDataLength + " characters.\")]\r\n");
        }
        if (foreignKey != null)
        {
            this.Write("        [global::System.ComponentModel.DataAnnotations.Schema.ForeignKeyAttribute(" + String.Join("+\",\"+", foreignKey.PropertyPairs.Select(x => String.Format("nameof({0})", x.DependentProperty.Name))) + ")]\r\n");
        }

        if (this.context.EnableNamingAlias || IdentifierMappings.ContainsKey(originalPropertyName))
        {
            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");
            this.Write(this.ToStringHelper.ToStringWithCulture(originalPropertyName));
            this.Write("\")]\r\n");
        }

        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(propertyType));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(fixedPropertyName));

        this.Write("\r\n        {\r\n            get\r\n            {\r\n                return this.__Values.Get(ref this.");

        this.Write(this.ToStringHelper.ToStringWithCulture(privatePropertyName));

        this.WriteLine(");\r\n            }\r\n            set\r\n            {");
        this.WriteLine("                var firstTime = this.__Values.InitField(ref {0});", this.ToStringHelper.ToStringWithCulture(privatePropertyName));
        this.WriteLine("                var wasChanged = this.{0}.IsChanged;", this.ToStringHelper.ToStringWithCulture(privatePropertyName));

        this.WriteLine("                if (!this.{0}.Equals(this.{0}.GetValue(), value))\r\n                {{", this.ToStringHelper.ToStringWithCulture(privatePropertyName));
        if (foreignKey == null)
        {
            this.WriteLine("                    this.On{0}Changing(value);", this.ToStringHelper.ToStringWithCulture(propertyName));
            this.WriteLine("                    this.{0}.SetValue(value);", this.ToStringHelper.ToStringWithCulture(privatePropertyName));
            this.WriteLine("                    this.On{0}Changed();", this.ToStringHelper.ToStringWithCulture(propertyName));
        }
        else
        {
            // Allow On{FK}Changing to cancel the object change process as well.
            this.WriteLine("                    this.On{0}Changing(value);", this.ToStringHelper.ToStringWithCulture(propertyName));
            foreach(var reference in foreignKey.PropertyPairs)
                this.WriteLine("                    if(value != null) this.On{0}Changing(value.{1});", this.ToStringHelper.ToStringWithCulture(reference.DependentProperty.Name), this.ToStringHelper.ToStringWithCulture(reference.PrincipalProperty.Name));
            this.WriteLine("                    this.{0}.SetValue(value);", this.ToStringHelper.ToStringWithCulture(privatePropertyName));
            this.WriteLine("                    this.On{0}Changed();", this.ToStringHelper.ToStringWithCulture(propertyName));
            foreach (var reference in foreignKey.PropertyPairs)
                this.WriteLine("                    if(value != null) this.{0} = value.{1};", this.ToStringHelper.ToStringWithCulture(reference.DependentProperty.Name), this.ToStringHelper.ToStringWithCulture(reference.PrincipalProperty.Name));
        }

        if (writeOnPropertyChanged)
        {
            // CS: Calling SetValue above handles the IsChanged events automatically.
            //this.WriteLine("                    this.SetChanged();");
            // CS: But we still need to Raise PropertyChanged, especially when the value reverts back to unchanged state.
            this.Write("                    this.OnPropertyChanged();\r\n");
        }

        this.WriteLine("                }");

        if (writeOnPropertyChanged)
        {
            this.WriteLine("                if (firstTime || this.{0}.IsChanged != wasChanged)", this.ToStringHelper.ToStringWithCulture(privatePropertyName));
            this.WriteLine("                    this.OnPropertyChanged(nameof({0}HasChanged));", this.ToStringHelper.ToStringWithCulture(propertyName));
        }


        this.WriteLine("            }\r\n        }");
        if (isComplexType)
            this.WriteLine("        private ComplexValueTracker<{0}> {1} = new ComplexValueTracker<{0}>({2});", this.ToStringHelper.ToStringWithCulture(propertyType), this.ToStringHelper.ToStringWithCulture(privatePropertyName), this.ToStringHelper.ToStringWithCulture(propertyInitializationValue != null ? propertyInitializationValue : string.Empty));
        else
            this.WriteLine("        private ValueTracker<{0}> {1} = new ValueTracker<{0}>({2});", this.ToStringHelper.ToStringWithCulture(propertyType), this.ToStringHelper.ToStringWithCulture(privatePropertyName), this.ToStringHelper.ToStringWithCulture(propertyInitializationValue != null ? propertyInitializationValue : string.Empty));

        this.WriteLine("        partial void On{0}Changing({1} value);", this.ToStringHelper.ToStringWithCulture(propertyName), this.ToStringHelper.ToStringWithCulture(propertyType));

        this.WriteLine("        partial void On{0}Changed();", this.ToStringHelper.ToStringWithCulture(propertyName));

        this.WriteGeneratedCodeAttribute();
        this.WriteLine("        [FormMetaData]");
        this.WriteLine("        [System.Runtime.Serialization.IgnoreDataMember]");
        this.WriteLine("        public bool {0}HasChanged {{ get => {1}.IsChanged; }}", this.ToStringHelper.ToStringWithCulture(propertyName), this.ToStringHelper.ToStringWithCulture(privatePropertyName));

    }


            internal override void WriteINotifyPropertyChangedImplementation()
    {
        // Write the 'HasChanges' implementation
        this.Write(@"
        #region IChangeTracking, IRevertibleChangeTracking
");

        this.Write(@"
        private bool __isChanged = false;
        /// <summary>
        /// IChangeTracking Notification that this record has changed since the graph was hydrated 
        /// </summary>
        /// <remarks>Helpful because change events now only fire if the value actually changes, so we can do a shallow check to determine if there is potential changes to send back to the server</remarks>
        /// <param name=""propertyName"">name of the property to raise the event for</param>");
        this.WriteGeneratedCodeAttribute();
        this.Write(@"
        public bool IsChanged
        {
            get => __isChanged;
        }
        /// <summary>
        /// Internally update the IsChanged state, this method handles a singleton change notification for the <see cref=""IsChanged""/> property.
        /// </summary>
        /// <param name=""isChanged""></param>
        protected void SetChanged(bool isChanged = true)
        {
            if(!isChanged)
            {
                // we have to re-evaluate the collection in this case
                isChanged = __Values.IsChanged;
            }

            if (__isChanged != isChanged)
            {
                __isChanged = isChanged;
                OnPropertyChanged(nameof(IsChanged));
            }
        }
");

        this.Write(@"
        /// <summary>
        /// Resets the object’s state to unchanged by accepting the modifications.
        /// </summary>");
        this.WriteGeneratedCodeAttribute();
        this.Write(@"
        public void AcceptChanges()
        {
            __Values.AcceptChanges();
        }
");

        this.Write(@"
        /// <summary>
        /// Post process this object after De-Serialization, accept the changes automatically so the record is in the unchanged state
        /// </summary>
        /// <remarks>This endpoint is obeyed by JSON.Net and DataContractSerializer and XmlSerializer</remarks>");
        this.WriteGeneratedCodeAttribute();
        this.Write(@"
        [global::System.Runtime.Serialization.OnDeserialized]
        private void OnDeserialized(global::System.Runtime.Serialization.StreamingContext context)
        {
            AcceptChanges();
            OnDeserialization(context);
        }");

        this.Write(@"
        /// <summary>
        /// Post process this object after De-Serialization, accept the changes automatically so the record is in the unchanged state
        /// </summary>
        /// <remarks>This endpoint is obeyed by dataContext.Configurations.ResponsePipeline.OnEntityMaterialized</remarks>");
        this.WriteGeneratedCodeAttribute();
        this.Write(@"
        void global::System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(global::System.Object sender)
        {
            AcceptChanges();
            OnDeserialization(sender);
        }
        /// <summary>
        /// Partial classes can implement custom logic to execute once the Entity has been materialized (after De-Serialization)
        /// You may need to call AcceptChanges() if you make any data changes during this implementation.
        /// </summary>
        /// <param name=""sender"">The owner of the process that materialized this record, this may be the container or the serialization context</param>
        /// <remarks>This endpoint is obeyed by JSON.Net, DataContractSerializer, XMLSerializer and OnEntityMaterialized (OData.Client)</remarks>
        partial void OnDeserialization(object sender);
");

        this.Write(@"
        #endregion IChangeTracking
");
        // Write IRevertibleChangeTracking implementations
        this.Write(@"
        #region IRevertibleChangeTracking

        public void RejectChanges()
        {
            this.__Values.RejectChanges();
        }

        #endregion IRevertibleChangeTracking
");
        // Write INotifyPropertyChanged implementations
        this.Write(@"
        #region INotifyPropertyChanged
");
        this.Write(@"
        /// <summary>
        /// Provided for external callers to raise the INotifyPropertyChanged event for force UI bindings to re-evaluate
        /// </summary>
        /// <remarks>Necessary because change events now only fire if the value actually changes</remarks>
        /// <param name=""propertyName"">name of the property to raise the event for</param>
        public void RaisePropertyChanged(string propertyName)
        {
            if(global::System.String.IsNullOrWhiteSpace(propertyName)) throw new global::System.ArgumentNullException(nameof(propertyName));
            this.OnPropertyChanged(propertyName);
        }

        /// <summary>
        /// Provided for external callers to raise the INotifyPropertyChanged event for all properties on this object to force UI bindings to re-evaluate
        /// </summary>
        /// <remarks>Necessary because change events now only fire if the value actually changes and for nested template binding scenarios where x:Bind won't work</remarks>
        public void RaiseAllPropertiesChanged()
        {
            foreach (var key in ((IChangeTrackerCache)this.__Values).Keys)
                this.OnPropertyChanged(key);
        }

");

        if (!this.context.UseAsyncDataServiceCollection)
        {
            this.Write("        /// <summary>\r\n        /// This event is raised when the value of the pro" +
                    "perty is changed\r\n        /// </summary>\r\n        [global::System.CodeDom.Compil" +
                    "er.GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

            this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

                    this.Write(@""")]
        public event global::System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        /// <summary>
        /// The value of the property is changed, raise INotifyPropertyChanged event
        /// </summary>
        /// <param name=""property"">property name</param>");
            WriteGeneratedCodeAttribute();


            this.Write(@"
        protected virtual void OnPropertyChanged([global::System.Runtime.CompilerServices.CallerMemberName] string property = null)
        {
            this.PropertyChanged?.Invoke(this, new global::System.ComponentModel.PropertyChangedEventArgs(property));
        }
");
        }
        else
        {
            // based on implementation from https://stackoverflow.com/a/45422891/1690217
            // In environments that do not support async binding operations natively...
            // To support async operations on properties that might be bound to UI (99% of the time that is why we want a change notification!)
            // We may need to track the original thread that the binding was registered on so that we can raise the event back on that thread.

            this.Write("        /// <summary>\r\n        /// Keep track of the synchronization context of " +
                    "each event handler that is registered.\r\n        /// </summary>\r\n        [global::System.CodeDom.Compil" +
                    "er.GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

            this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

            this.Write(@""")]
        private readonly global::System.Collections.Generic.List<(global::System.Threading.SynchronizationContext context, global::System.ComponentModel.PropertyChangedEventHandler handler)> _handlers = new global::System.Collections.Generic.List<(global::System.Threading.SynchronizationContext context, global::System.ComponentModel.PropertyChangedEventHandler handler)>();
");

            this.Write("        /// <summary>\r\n        /// This event is raised when the value of the pro" +
                    "perty is changed\r\n        /// </summary>\r\n        [global::System.CodeDom.Compil" +
                    "er.GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));
            this.Write(@""")]
        public event global::System.ComponentModel.PropertyChangedEventHandler PropertyChanged
        {
            add => _handlers.Add((global::System.Threading.SynchronizationContext.Current, value));
            remove
            {
                var i = 0;
                foreach (var item in _handlers)
                {
                    if (item.handler.Equals(value))
                    {
                        _handlers.RemoveAt(i);
                        break;
                    }
                    i++;
                }
            }
        }
");

            this.Write(@"        /// <summary>
        /// The value of the property is changed
        /// </summary>
        /// <param name=""property"">property name</param>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

            this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));
            this.Write(@""")]
        protected global::System.Threading.Tasks.Task OnPropertyChanged([global::System.Runtime.CompilerServices.CallerMemberName] string property = null)
        {
            var args = new global::System.ComponentModel.PropertyChangedEventArgs(property);
            var tasks = _handlers
                .GroupBy(x => x.context, x => x.handler)
                .Select(g => invokeContext(g.Key, g));
            return global::System.Threading.Tasks.Task.WhenAll(tasks);

            global::System.Threading.Tasks.Task invokeContext(global::System.Threading.SynchronizationContext context, global::System.Collections.Generic.IEnumerable<global::System.ComponentModel.PropertyChangedEventHandler> l)
            {
                if (context != null)
                {
                    var tcs = new global::System.Threading.Tasks.TaskCompletionSource<bool>();
                    context.Post(o =>
                    {
                        try { invokeHandlers(l); tcs.TrySetResult(true); }
                        catch (global::System.Exception e) { tcs.TrySetException(e); }
                    }, null);
                    return tcs.Task;
                }
                else
                {
                    return global::System.Threading.Tasks.Task.Run(() => invokeHandlers(l));
                }
            }
            void invokeHandlers(global::System.Collections.Generic.IEnumerable<global::System.ComponentModel.PropertyChangedEventHandler> l)
            {
                foreach (var h in l)
                    h(this, args);
            }
        }
");

        }

        this.Write(@"
#endregion INotifyPropertyChanged
");

    }

    internal override void WriteClassEndForStructuredType()
    {

        this.Write("    }\r\n");


    }

    internal override void WriteEnumFlags()
    {

        this.Write("    [global::System.Flags]\r\n");


    }

    internal override void WriteSummaryCommentForEnumType(string enumName)
    {

        this.Write("    /// <summary>\r\n    /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(enumName));

        this.Write(" in the schema.\r\n    /// </summary>\r\n");


    }

    internal override void WriteEnumDeclaration(string enumName, string originalEnumName, string underlyingType)
    {
        if (this.context.EnableNamingAlias)
        {

            this.Write("    [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalEnumName));

            this.Write("\")]\r\n");


        }

        this.Write("    public enum ");

        this.Write(this.ToStringHelper.ToStringWithCulture(enumName));

        this.Write(this.ToStringHelper.ToStringWithCulture(underlyingType));

        this.Write("\r\n    {\r\n");


    }

    internal override void WriteMemberForEnumType(string member, string originalMemberName, bool last)
    {
        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalMemberName));

            this.Write("\")]\r\n");


        }

        this.Write("        ");

        this.Write(this.ToStringHelper.ToStringWithCulture(member));

        this.Write(this.ToStringHelper.ToStringWithCulture(last ? string.Empty : ","));

        this.Write("\r\n");


    }

    internal override void WriteEnumEnd()
    {

        this.Write("    }\r\n");


    }

    internal override void WriteFunctionImportReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string parameters, string parameterValues, bool isComposable, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");


        }

        this.Write("        public global::Microsoft.OData.Client.DataServiceQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("> ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

        this.Write(")\r\n        {\r\n            return this.CreateFunctionQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(">(\"\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

        this.Write("\", ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower()));

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

        this.Write(");\r\n        }\r\n");


    }

    internal override void WriteFunctionImportWithInputWrapperReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");

        }

        this.WriteGeneratedCodeAttribute();

        this.Write("        public global::Microsoft.OData.Client.DataServiceQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("> ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(");

        this.Write(inputWrapperTypeName + " request");

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

        if (useEntityReference)
        {
            var temp = parameterNames.ToList();
            temp.Add("useEntityReference");
            parameterNames = temp.ToArray();
        }

        this.Write(")\r\n        {\r\n            return this." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));
        this.Write(");\r\n        }\r\n");

    }

    internal override void WriteFunctionImportReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");


        }
        this.WriteGeneratedCodeAttribute();
        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

        this.Write(")\r\n        {\r\n            return ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "new " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

        this.Write("this.CreateFunctionQuerySingle<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(">(\"\", \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

        this.Write("\", ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower()));

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

        this.Write(")");

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

        this.Write(";\r\n        }\r\n");


    }

    internal override void WriteFunctionImportWithInputWrapperReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string inputWrapperTypeName, string[] parameterNames, bool isReturnEntity, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");


        }

        this.WriteGeneratedCodeAttribute();

        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(");

        this.Write(inputWrapperTypeName + " request");

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

        if (useEntityReference)
        {
            var temp = parameterNames.ToList();
            temp.Add("useEntityReference");
            parameterNames = temp.ToArray();
        }

        this.Write(")\r\n        {\r\n            return this." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));
        this.Write(");\r\n        }\r\n");

    }

    internal override void WriteBoundFunctionInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");


        }

        this.WriteGeneratedCodeAttribute();

        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

        this.Write("global::Microsoft.OData.Client.DataServiceQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("> ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

        this.Write(")\r\n        {\r\n            global::System.Uri requestUri;\r\n            Context.Try" +
                "GetUri(this, out requestUri);\r\n            return this.Context.CreateFunctionQue" +
                "ry<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(">(string.Join(\"/\", global::System.Linq.Enumerable.Select(global::System.Linq.Enum" +
                "erable.Skip(requestUri.Segments, this.Context.BaseUri.Segments.Length), s => s.T" +
                "rim(\'/\'))), \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

        this.Write(".");

        this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

        this.Write("\", ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower()));

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

        this.Write(");\r\n        }\r\n");


    }
    
    internal override void WriteBoundFunctionWithInputWrapperInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");

        this.WriteGeneratedCodeAttribute();


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");


        }

        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

        this.Write("global::Microsoft.OData.Client.DataServiceQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("> ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(");

        this.Write(inputWrapperTypeName + " request");

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

        if (useEntityReference)
        {
            var temp = parameterNames.ToList();
            temp.Add("useEntityReference");
            parameterNames = temp.ToArray();
        }

        this.Write(")\r\n        {\r\n            return this." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));
        this.Write(");\r\n        }\r\n");
    }

    internal override void WriteBoundFunctionInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");


        }

        this.WriteGeneratedCodeAttribute();
        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

        this.Write(")\r\n        {\r\n            global::System.Uri requestUri;\r\n            Context.Try" +
                "GetUri(this, out requestUri);\r\n\r\n            return ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "new " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

        this.Write("this.Context.CreateFunctionQuerySingle<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(">(string.Join(\"/\", global::System.Linq.Enumerable.Select(global::System.Linq.Enum" +
                "erable.Skip(requestUri.Segments, this.Context.BaseUri.Segments.Length), s => s.T" +
                "rim(\'/\'))), \"");

        this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

        this.Write(".");

        this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

        this.Write("\", ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower()));

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

        this.Write(")");

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

        this.Write(";\r\n        }\r\n");


    }
    internal override void WriteBoundFunctionWithInputWrapperInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string inputWrapperTypeName, string [] parameterNames, string fullNamespace, bool isReturnEntity, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");

        this.WriteGeneratedCodeAttribute();

        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");


        }

        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(");

        this.Write(inputWrapperTypeName + " request");

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

        if (useEntityReference)
        {
            var temp = parameterNames.ToList();
            temp.Add("useEntityReference");
            parameterNames = temp.ToArray();
        }

        this.Write(")\r\n        {\r\n            return this." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));
        this.Write(");\r\n        }\r\n");
    }

    internal override void WriteActionImport(string actionName, string originalActionName, string returnTypeName, string parameters, string parameterValues)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

            this.Write("\")]\r\n");


        }

        this.WriteGeneratedCodeAttribute();
        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

        this.Write("(");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

        this.Write(")\r\n        {\r\n            return new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("(this, this.BaseUri.OriginalString.Trim(\'/\') + \"/");

        this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

        this.Write("\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

        this.Write(");\r\n        }\r\n");


    }
    internal override void WriteActionImportWithInputWrapper(string actionName, string originalActionName, string returnTypeName, string inputWrapperTypeName, string [] parameterNames)
    {
        var parsedActionName = this.ToStringHelper.ToStringWithCulture(actionName);

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(parsedActionName);

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

            this.Write("\")]\r\n");


        }

        this.WriteGeneratedCodeAttribute();

        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(" ");

        this.Write(parsedActionName);

        this.Write("(");

        this.Write(inputWrapperTypeName + " request");

        this.Write(")\r\n        {\r\n            return new ");

        this.Write(")\r\n        {\r\n            return this." + parsedActionName + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));
        this.Write(");\r\n        }\r\n");

    }

    internal override void WriteBoundActionInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

            this.Write("\")]\r\n");


        }

        this.WriteGeneratedCodeAttribute();
        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

        this.Write("(");

        this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

        this.Write(@")
{
    global::Microsoft.OData.Client.EntityDescriptor resource = Context.EntityTracker.TryGetEntityDescriptor(this);
    if (resource == null)
    {
        throw new global::System.Exception(""cannot find entity"");
    }

    return new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("(this.Context, resource.EditLink.OriginalString.Trim(\'/\') + \"/");

        this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

        this.Write(".");

        this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

        this.Write("\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

        this.Write(");\r\n        }\r\n");


    }

    internal override void WriteBoundActionWithInputWrapperInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace)
    {
        string parsedActionName = this.ToStringHelper.ToStringWithCulture(actionName);

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(parsedActionName);

        this.Write(" in the schema.\r\n        /// </summary>\r\n");

        this.WriteGeneratedCodeAttribute();

        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

            this.Write("\")]\r\n");


        }

        this.Write("        public ");

        this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(" ");

        this.Write(parsedActionName);

        this.Write("(");

        this.Write(inputWrapperTypeName + " request");

        this.Write(")\r\n        {\r\n            return this." + parsedActionName + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));
        this.Write(");\r\n        }\r\n");
    }

    internal override void WriteExtensionMethodsStart()
    {

        this.Write("    /// <summary>\r\n    /// Class containing all extension methods\r\n    /// </summ" +
                "ary>\r\n    public static class ExtensionMethods\r\n    {\r\n");


    }

    internal override void WriteExtensionMethodsEnd()
    {

        this.Write("    }\r\n");


    }

    internal override void WriteByKeyMethods(string entityTypeName, string returnTypeName, IEnumerable<string> keys, string keyParameters, string keyDictionaryItems)
    {

        this.Write("        /// <summary>\r\n        /// Get an entity of type ");

        this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

        this.Write(" as ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(" specified by key from an entity set\r\n        /// </summary>\r\n        /// <param " +
                "name=\"_source\">source entity set</param>\r\n        /// <param name=\"keys\">dictiona" +
                "ry with the names and values of keys</param>\r\n        public static ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(" ByKey(this global::Microsoft.OData.Client.DataServiceQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

        this.Write("> _source, global::System.Collections.Generic.Dictionary<string, object> keys)\r\n  " +
                "      {\r\n            return new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("(_source.Context, _source.GetKeyPath(global::Microsoft.OData.Client.Serializer.GetK" +
                "eyString(_source.Context, keys)));\r\n        }\r\n        /// <summary>\r\n        ///" +
                " Get an entity of type ");

        this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

        this.Write(" as ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(" specified by key from an entity set\r\n        /// </summary>\r\n        /// <param " +
                "name=\"_source\">source entity set</param>\r\n");


        foreach (var key in keys)
        {

            this.Write("        /// <param name=\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(key));

            this.Write("\">The value of ");

            this.Write(this.ToStringHelper.ToStringWithCulture(key));

            this.Write("</param>\r\n");


        }

        this.Write("        public static ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(" ByKey(this global::Microsoft.OData.Client.DataServiceQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

        this.Write("> _source,\r\n            ");

        this.Write(this.ToStringHelper.ToStringWithCulture(keyParameters));

        this.Write(")\r\n        {\r\n            global::System.Collections.Generic.Dictionary<string, o" +
                "bject> keys = new global::System.Collections.Generic.Dictionary<string, object>\r" +
                "\n            {\r\n                ");

        this.Write(this.ToStringHelper.ToStringWithCulture(keyDictionaryItems));

        this.Write("\r\n            };\r\n            return new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("(_source.Context, _source.GetKeyPath(global::Microsoft.OData.Client.Serializer.GetK" +
                "eyString(_source.Context, keys)));\r\n        }\r\n");


    }

    internal override void WriteCastToMethods(string baseTypeName, string derivedTypeName, string derivedTypeFullName, string returnTypeName)
    {

        this.Write("        /// <summary>\r\n        /// Cast an entity of type ");

        this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

        this.Write(" to its derived type ");

        this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

        this.Write("\r\n        /// </summary>\r\n        /// <param name=\"_source\">source entity</param>\r" +
                "\n        public static ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(" CastTo");

        this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeName));

        this.Write("(this global::Microsoft.OData.Client.DataServiceQuerySingle<");

        this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

        this.Write("> _source)\r\n        {\r\n            global::Microsoft.OData.Client.DataServiceQuery" +
                "Single<");

        this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

        this.Write("> query = _source.CastTo<");

        this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

        this.Write(">();\r\n            return new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("(_source.Context, query.GetPath(null));\r\n        }\r\n");


    }

    internal override void WriteBoundFunctionReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");


        }

        this.WriteGeneratedCodeAttribute();
        this.Write("        public static ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(this ");

        this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

        this.Write(" _source");

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

        this.Write(")\r\n        {\r\n            if (!_source.IsComposable)\r\n            {\r\n             " +
                "   throw new global::System.NotSupportedException(\"The previous function is not " +
                "composable.\");\r\n            }\r\n\r\n            return ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "new " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

        this.Write("_source.CreateFunctionQuerySingle<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(">(\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

        this.Write(".");

        this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

        this.Write("\", ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower()));

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

        this.Write(")");

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

        this.Write(";\r\n        }\r\n");


    }
    internal override void WriteBoundFunctionWithInputWrapperReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string inputWrapperTypeName, string[] parameterNames, string fullNamespace, bool isReturnEntity, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");

        this.WriteGeneratedCodeAttribute();


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");


        }

        this.Write("        public static ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

        this.Write(" ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(this ");

        this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

        this.Write(" _source");

        this.Write(this.ToStringHelper.ToStringWithCulture(", " + inputWrapperTypeName + " request"));

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = false" : string.Empty));

        if (useEntityReference)
        {
            var temp = parameterNames.ToList();
            temp.Add("useEntityReference");
            parameterNames = temp.ToArray();
        }

        this.Write(")\r\n        {\r\n            return _source." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));
        this.Write(");\r\n        }\r\n");



    }

    internal override void WriteBoundFunctionReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");


        }

        this.WriteGeneratedCodeAttribute();
        this.Write("        public static global::Microsoft.OData.Client.DataServiceQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("> ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(this ");

        this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

        this.Write(" _source");

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = true" : string.Empty));

        this.Write(")\r\n        {\r\n            if (!_source.IsComposable)\r\n            {\r\n             " +
                "   throw new global::System.NotSupportedException(\"The previous function is not " +
                "composable.\");\r\n            }\r\n\r\n            return _source.CreateFunctionQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(">(\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

        this.Write(".");

        this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

        this.Write("\", ");

        this.Write(this.ToStringHelper.ToStringWithCulture(isComposable.ToString().ToLower()));

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

        this.Write(");\r\n        }\r\n");


    }
    internal override void WriteBoundFunctionWithInputWrapperReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace, bool useEntityReference)
    {

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write(" in the schema.\r\n        /// </summary>\r\n");

        this.WriteGeneratedCodeAttribute();


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

            this.Write("\")]\r\n");


        }

        this.Write("        public static global::Microsoft.OData.Client.DataServiceQuery<");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("> ");

        this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

        this.Write("(this ");

        this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

        this.Write(" _source");

        this.Write(this.ToStringHelper.ToStringWithCulture(", " + inputWrapperTypeName + " request"));

        this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", bool useEntityReference = true" : string.Empty));

        if (useEntityReference)
        {
            var temp = parameterNames.ToList();
            temp.Add("useEntityReference");
            parameterNames = temp.ToArray();
        }

        this.Write(")\r\n        {\r\n            return _source." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));
        this.Write(");\r\n        }\r\n");

    }

    internal override void WriteBoundActionAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string parameters, string fullNamespace, string parameterValues)
    {
        string parsedActionName = this.ToStringHelper.ToStringWithCulture(actionName);

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(parsedActionName);

        this.Write(" in the schema.\r\n        /// </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

            this.Write("\")]\r\n");


        }

        this.Write("        public static ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(" ");

        this.Write(parsedActionName);

        this.Write("(this ");

        this.Write(this.ToStringHelper.ToStringWithCulture(boundSourceType));

        this.Write(" _source");

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

        this.Write(")\r\n        {\r\n            if (!_source.IsComposable)\r\n            {\r\n             " +
                "   throw new global::System.NotSupportedException(\"The previous function is not " +
                "composable.\");\r\n            }\r\n\r\n            return new ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write("(_source.Context, _source.AppendRequestUri(\"");

        this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

        this.Write(".");

        this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

        this.Write("\")");

        this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

        this.Write(");\r\n        }\r\n");
    }

    internal override void WriteBoundActionWithInputWrapperAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace)
    {
        string parsedActionName = this.ToStringHelper.ToStringWithCulture(actionName);

        this.Write("        /// <summary>\r\n        /// There are no comments for ");

        this.Write(parsedActionName);

        this.Write(" in the schema.\r\n        /// </summary>\r\n");

        this.WriteGeneratedCodeAttribute();

        if (this.context.EnableNamingAlias)
        {

            this.Write("        [global::Microsoft.OData.Client.OriginalNameAttribute(\"");

            this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

            this.Write("\")]\r\n");


        }

        this.Write("        public static ");

        this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

        this.Write(" ");

        this.Write(parsedActionName);

        this.Write("(this ");

        this.Write(this.ToStringHelper.ToStringWithCulture(boundSourceType));

        this.Write(" _source");

        this.Write(this.ToStringHelper.ToStringWithCulture(", " + inputWrapperTypeName + " request"));

        this.Write(")\r\n        {\r\n            return _source." + parsedActionName + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));
        this.Write(");\r\n        }\r\n");
    }


    internal override void WriteNamespaceEnd()
    {

this.Write("}\r\n");


    }
}

public sealed class ODataClientVBTemplate : ODataClientTemplate
{
    /// <summary>
    /// Creates an instance of the ODataClientTemplate.
    /// </summary>
    /// <param name="context">The cotion context.</param>
    public ODataClientVBTemplate(CodeGenerationContext context)
        : base(context)
    {
    }

    internal override string GlobalPrefix { get { return string.Empty; } }
    internal override string SystemTypeTypeName { get { return "Global.System.Type"; } }
    internal override string AbstractModifier { get { return " MustInherit"; } }
    internal override string DataServiceActionQueryTypeName { get { return "Global.Microsoft.OData.Client.DataServiceActionQuery"; } }
    internal override string DataServiceActionQuerySingleOfTStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceActionQuerySingle(Of {0})"; } }
    internal override string DataServiceActionQueryOfTStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceActionQuery(Of {0})"; } }
    internal override string NotifyPropertyChangedModifier { get { return "\r\n        Implements Global.System.ComponentModel.INotifyPropertyChanged"; } }
    internal override string ClassInheritMarker { get { return "\r\n        Inherits "; } }
    internal override string ParameterSeparator { get { return ",  _\r\n                    "; } }
    internal override string KeyParameterSeparator { get { return ",  _\r\n            "; } }
    internal override string KeyDictionaryItemSeparator { get { return ",  _\r\n                "; } }
    internal override string SystemNullableStructureTemplate { get { return "Global.System.Nullable(Of {0})"; } }
    internal override string ICollectionOfTStructureTemplate { get { return "Global.System.Collections.Generic.ICollection(Of {0})"; } }
    internal override string DataServiceCollectionStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceCollection(Of {0})"; } }
    internal override string DataServiceQueryStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceQuery(Of {0})"; } }
    internal override string DataServiceQuerySingleStructureTemplate { get { return "Global.Microsoft.OData.Client.DataServiceQuerySingle(Of {0})"; } }
    internal override string ObservableCollectionStructureTemplate { get { return "Global.System.Collections.ObjectModel.ObservableCollection(Of {0})"; } }
    internal override string ObjectModelCollectionStructureTemplate { get { return "Global.System.Collections.ObjectModel.Collection(Of {0})"; } }
    internal override string DataServiceCollectionConstructorParameters { get { return "(Nothing, Global.Microsoft.OData.Client.TrackingMode.None)"; } }
    internal override string NewModifier { get { return "New "; } }
    internal override string GeoTypeInitializePattern { get { return "Global.Microsoft.Spatial.SpatialImplementation.CurrentImplementation.CreateWellKnownTextSqlFormatter(False).Read(Of {0})(New Global.System.IO.StringReader(\"{1}\"))"; } }
    internal override string Int32TypeName { get { return "Integer"; } }
    internal override string ObjectTypeName { get { return "Object"; } }
    internal override string StringTypeName { get { return "String"; } }
    internal override string BinaryTypeName { get { return "Byte()"; } }
    internal override string DecimalTypeName { get { return "Decimal"; } }
    internal override string Int16TypeName { get { return "Short"; } }
    internal override string SingleTypeName { get { return "Single"; } }
    internal override string BooleanTypeName { get { return "Boolean"; } }
    internal override string DoubleTypeName { get { return "Double"; } }
    internal override string GuidTypeName { get { return "Global.System.Guid"; } }
    internal override string ByteTypeName { get { return "Byte"; } }
    internal override string Int64TypeName { get { return "Long"; } }
    internal override string SByteTypeName { get { return "SByte"; } }
    internal override string DataServiceStreamLinkTypeName { get { return "Global.Microsoft.OData.Client.DataServiceStreamLink"; } }
    internal override string GeographyTypeName { get { return "Global.Microsoft.Spatial.Geography"; } }
    internal override string GeographyPointTypeName { get { return "Global.Microsoft.Spatial.GeographyPoint"; } }
    internal override string GeographyLineStringTypeName { get { return "Global.Microsoft.Spatial.GeographyLineString"; } }
    internal override string GeographyPolygonTypeName { get { return "Global.Microsoft.Spatial.GeographyPolygon"; } }
    internal override string GeographyCollectionTypeName { get { return "Global.Microsoft.Spatial.GeographyCollection"; } }
    internal override string GeographyMultiPolygonTypeName { get { return "Global.Microsoft.Spatial.GeographyMultiPolygon"; } }
    internal override string GeographyMultiLineStringTypeName { get { return "Global.Microsoft.Spatial.GeographyMultiLineString"; } }
    internal override string GeographyMultiPointTypeName { get { return "Global.Microsoft.Spatial.GeographyMultiPoint"; } }
    internal override string GeometryTypeName { get { return "Global.Microsoft.Spatial.Geometry"; } }
    internal override string GeometryPointTypeName { get { return "Global.Microsoft.Spatial.GeometryPoint"; } }
    internal override string GeometryLineStringTypeName { get { return "Global.Microsoft.Spatial.GeometryLineString"; } }
    internal override string GeometryPolygonTypeName { get { return "Global.Microsoft.Spatial.GeometryPolygon"; } }
    internal override string GeometryCollectionTypeName { get { return "Global.Microsoft.Spatial.GeometryCollection"; } }
    internal override string GeometryMultiPolygonTypeName { get { return "Global.Microsoft.Spatial.GeometryMultiPolygon"; } }
    internal override string GeometryMultiLineStringTypeName { get { return "Global.Microsoft.Spatial.GeometryMultiLineString"; } }
    internal override string GeometryMultiPointTypeName { get { return "Global.Microsoft.Spatial.GeometryMultiPoint"; } }
    internal override string DateTypeName { get { return "Global.Microsoft.OData.Edm.Date"; } }
    internal override string DateTimeOffsetTypeName { get { return "Global.System.DateTimeOffset"; } }
    internal override string DurationTypeName { get { return "Global.System.TimeSpan"; } }
    internal override string TimeOfDayTypeName { get { return "Global.Microsoft.OData.Edm.TimeOfDay"; } }
    internal override string XmlConvertClassName { get { return "Global.System.Xml.XmlConvert"; } }
    internal override string EnumTypeName { get { return "Global.System.Enum"; } }
    internal override string DictionaryTypeName { get { return "Global.System.Collections.Generic.Dictionary(Of {0}, {1})"; } }
    internal override string FixPattern { get { return "[{0}]"; } }
    internal override string EnumUnderlyingTypeMarker { get { return " As "; } }
    internal override string ConstantExpressionConstructorWithType { get { return "Global.System.Linq.Expressions.Expression.Constant({0}, GetType({1}))"; } }
    internal override string TypeofFormatter { get { return "GetType({0})"; } }    
    internal override string UriOperationParameterConstructor { get { return "New Global.Microsoft.OData.Client.UriOperationParameter(\"{0}\", {1})"; } }
    internal override string UriEntityOperationParameterConstructor { get { return "New Global.Microsoft.OData.Client.UriEntityOperationParameter(\"{0}\", {1}, {2})"; } }
    internal override string BodyOperationParameterConstructor { get { return "New Global.Microsoft.OData.Client.BodyOperationParameter(\"{0}\", {1})"; } }
    internal override string DictionaryConstructor { get { return $"New {DictionaryTypeName}"; } }
    internal override string BaseEntityType { get { return "\r\n        Inherits Global.Microsoft.OData.Client.BaseEntityType"; } }
    internal override string OverloadsModifier { get { return "Overloads "; } }
    internal override string ODataVersion { get { return "Global.Microsoft.OData.ODataVersion.V4"; } }
    internal override string ParameterDeclarationTemplate { get { return "{1} As {0}"; } }
    internal override string DictionaryItemConstructor { get { return "{{ {0}, {1} }}"; } }
    internal override HashSet<string> LanguageKeywords { get { 
        if (VBKeywords == null)
        {
            VBKeywords = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
            {
                "AddHandler", "AddressOf", "Alias", "And", "AndAlso", "As", "Boolean", "ByRef", "Byte", "ByVal",
                "Call", "Case", "Catch", "CBool", "", "CByte", "CChar", "CDate", "CDbl", "CDec", "Char", 
                "CInt", "Class", "CLng", "CObj", "Const", "Continue", "CSByte", "CShort", "CSng", "CStr",
                "CType", "CUInt", "CULng", "CUShort", "Date", "Decimal", "Declare", "Default", "Delegate", "Dim",
                "DirectCast", "Do", "Double", "Each", "Else", "ElseIf", "End", "EndIf", "Enum", "Erase",
                "Error", "Event", "Exit", "False", "Finally", "For", "Friend", "Function", "Get", "GetType",
                "GetXMLNamespace", "Global", "GoSub", "GoTo", "Handles", "If", "Implements", "Imports", "In", "Inherits",
                "Integer", "Interface", "Is", "IsNot", "Let", "Lib", "Like", "Long", "Loop", "Me",
                "Mod", "Module", "MustInherit", "MustOverride", "MyBase", "MyClass", "Namespace", "Narrowing", "New", "Next",
                "Not", "Nothing", "NotInheritable", "NotOverridable", "Object", "Of", "On", "Operator", "Option", "Optional",
                "Or", "OrElse", "Out", "Overloads", "Overridable", "Overrides", "ParamArray", "Partial", "Private", "Property",
                "Protected", "Public", "RaiseEvent", "ReadOnly", "ReDim", "REM", "RemoveHandler", "Resume", "Return", "SByte",
                "Select", "Set", "Shadows", "Shared", "Short", "Single", "Static", "Step", "Stop", "String", 
                "Structure", "Sub", "SyncLock", "Then", "Throw", "To", "True", "Try", "TryCast", "TypeOf", 
                "UInteger", "ULong", "UShort", "Using", "Variant", "Wend", "When", "While", "Widening", "With", 
                "WithEvents", "WriteOnly", "Xor"
            };
        }
        return VBKeywords;
    } }
    private HashSet<string> VBKeywords;

    /// <summary>
    /// Write out the <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> for a member that declares the name of this tool and the current version.
    /// If this is a debug build, the name of the calling method that executed this method will be injected as the Tool to assist with debugging and extension development
    /// </summary>
    /// <param name="member">Name of the method that called into this method</param>
    /// <remarks>Member name is only visible during debugging</remarks>
    internal override void WriteGeneratedCodeAttribute([System.Runtime.CompilerServices.CallerMemberName] string member = null)
    {
        this.Write("        <global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"");
#if DEBUG
        this.Write(member);
#else
this.Write("Microsoft.OData.Client.Design.T4");
#endif

        this.Write("\",\"");
        this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));
        this.Write("\")>\r\n _");
    }

    internal override void WriteFileHeader()
    {

this.Write("\'------------------------------------------------------------------------------\r\n" +
        "\' <auto-generated>\r\n\'     This code was generated by a tool.\r\n\'     Runtime Vers" +
        "ion:");

this.Write(this.ToStringHelper.ToStringWithCulture(Environment.Version));

this.Write(@"
'
'     Changes to this file may cause incorrect behavior and will be lost if
'     the code is regenerated.
' </auto-generated>
'------------------------------------------------------------------------------

Option Strict Off
Option Explicit On


'Generation date: ");

this.Write(this.ToStringHelper.ToStringWithCulture(DateTime.Now.ToString(System.Globalization.CultureInfo.CurrentCulture)));

this.Write("\r\n");


    }

    internal override void WriteNamespaceStart(string fullNamespace)
    {

this.Write("Namespace ");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write("\r\n");


    }

    internal override void WriteClassStartForEntityContainer(string originalContainerName, string containerName, string fixedContainerName)
    {

this.Write("    \'\'\'<summary>\r\n    \'\'\'There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(containerName));

this.Write(" in the schema.\r\n    \'\'\'</summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("    <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalContainerName));

this.Write("\")>  _\r\n");


        }

this.Write("    Partial Public Class ");

this.Write(this.ToStringHelper.ToStringWithCulture(fixedContainerName));

this.Write("\r\n        Inherits Global.Microsoft.OData.Client.DataServiceContext\r\n");


    }

    internal override void WriteMethodStartForEntityContainerConstructor(string containerName, string fixedContainerName)
    {

this.Write("        \'\'\'<summary>\r\n        \'\'\'Initialize a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(containerName));

this.Write(" object.\r\n        \'\'\'</summary>\r\n        <Global.System.CodeDom.Compiler.Generate" +
        "dCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Public Sub New(ByVal serviceRoot As Global.System.Uri)\r\n         " +
        "   MyBase.New(serviceRoot, Global.Microsoft.OData.Client.ODataProtocolVersion.V4" +
        ")\r\n");


    }

    internal override void WriteKeyAsSegmentUrlConvention()
    {

this.Write("            Me.UrlKeyDelimiter = Global.Microsoft.OData.Client.DataServiceUrlKeyD" +
        "elimiter.Slash\r\n");


    }

    internal override void WriteInitializeResolveName()
    {

this.Write("            Me.ResolveName = AddressOf Me.ResolveNameFromType\r\n");


    }

    internal override void WriteInitializeResolveType()
    {

this.Write("            Me.ResolveType = AddressOf Me.ResolveTypeFromName\r\n");


    }

    internal override void WriteClassEndForEntityContainerConstructor()
    {

this.Write("            Me.OnContextCreated\r\n            Me.Format.LoadServiceModel = Address" +
        "Of GeneratedEdmModel.GetInstance\r\n            Me.Format.UseJson()\r\n        End S" +
        "ub\r\n        Partial Private Sub OnContextCreated()\r\n        End Sub\r\n");


    }

    internal override void WriteMethodStartForResolveTypeFromName()
    {

this.Write(@"        '''<summary>
        '''Since the namespace configured for this service reference
        '''in Visual Studio is different from the one indicated in the
        '''server schema, use type-mappers to map between the two.
        '''</summary>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Protected Function ResolveTypeFromName(ByVal typeName As String) " +
        "As Global.System.Type\r\n");


    }

    internal override void WriteResolveNamespace(string typeName, string fullNamespace, string languageDependentNamespace)
    {
        if (!string.IsNullOrEmpty(typeName))
        {

this.Write("            Dim resolvedType As ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write("= Me.DefaultResolveType(typeName, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write("\", String.Concat(ROOTNAMESPACE, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(languageDependentNamespace));

this.Write("\"))\r\n");


        }
        else
        {

this.Write("            resolvedType = Me.DefaultResolveType(typeName, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write("\", String.Concat(ROOTNAMESPACE, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(languageDependentNamespace));

this.Write("\"))\r\n");


        }

this.Write("            If (Not (resolvedType) Is Nothing) Then\r\n                Return resol" +
        "vedType\r\n            End If\r\n");


    }

    internal override void WriteMethodEndForResolveTypeFromName()
    {

this.Write("            Return Nothing\r\n        End Function\r\n");


    }
    
    internal override void WritePropertyRootNamespace(string containerName, string fullNamespace)
    {

this.Write("        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData.C" +
        "lient.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Private Shared ROOTNAMESPACE As String = GetType(");

this.Write(this.ToStringHelper.ToStringWithCulture(containerName));

this.Write(").Namespace.Remove(GetType(");

this.Write(this.ToStringHelper.ToStringWithCulture(containerName));

this.Write(").Namespace.LastIndexOf(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write("\"))\r\n");


    }

    internal override void WriteMethodStartForResolveNameFromType(string containerName, string fullNamespace)
    {

this.Write(@"        '''<summary>
        '''Since the namespace configured for this service reference
        '''in Visual Studio is different from the one indicated in the
        '''server schema, use type-mappers to map between the two.
        '''</summary>
        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Protected Function ResolveNameFromType(ByVal clientType As Global" +
        ".System.Type) As String\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write(@"            Dim originalNameAttribute As Global.Microsoft.OData.Client.OriginalNameAttribute =
                CType(Global.System.Linq.Enumerable.SingleOrDefault(Global.Microsoft.OData.Client.Utility.GetCustomAttributes(clientType, GetType(Global.Microsoft.OData.Client.OriginalNameAttribute), true)), Global.Microsoft.OData.Client.OriginalNameAttribute)
");


    }
    }

    internal override void WriteResolveType(string fullNamespace, string languageDependentNamespace)
    {

this.Write("            If clientType.Namespace.Equals(String.Concat(ROOTNAMESPACE, \"");

this.Write(this.ToStringHelper.ToStringWithCulture(languageDependentNamespace));

this.Write("\"), Global.System.StringComparison.OrdinalIgnoreCase) Then\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("                If (Not (originalNameAttribute) Is Nothing) Then\r\n               " +
        "     Return String.Concat(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".\", originalNameAttribute.OriginalName)\r\n                End If\r\n");


        }

this.Write("                Return String.Concat(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".\", clientType.Name)\r\n            End If\r\n");


    }

    internal override void WriteMethodEndForResolveNameFromType(bool modelHasInheritance)
    {
        if (this.context.EnableNamingAlias && modelHasInheritance)
        {

this.Write(@"            If (Not (originalNameAttribute) Is Nothing) Then
                Dim fullName As String = clientType.FullName.Substring(ROOTNAMESPACE.Length)
                Return fullName.Remove(fullName.LastIndexOf(clientType.Name)) + originalNameAttribute.OriginalName
            End If
");


        }

this.Write("            Return ");

this.Write(this.ToStringHelper.ToStringWithCulture(modelHasInheritance ? "clientType.FullName.Substring(ROOTNAMESPACE.Length)" : "Nothing"));

this.Write("\r\n        End Function\r\n");


    }

    internal override void WriteConstructorForSingleType(string singleTypeName, string baseTypeName)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' Initialize a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write(@" object.
        ''' </summary>
        Public Sub New(ByVal context As Global.Microsoft.OData.Client.DataServiceContext, ByVal path As String)
            MyBase.New(context, path)
        End Sub

        ''' <summary>
        ''' Initialize a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write(@" object.
        ''' </summary>
        Public Sub New(ByVal context As Global.Microsoft.OData.Client.DataServiceContext, ByVal path As String, ByVal isComposable As Boolean)
            MyBase.New(context, path, isComposable)
        End Sub

        ''' <summary>
        ''' Initialize a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(singleTypeName));

this.Write(" object.\r\n        \'\'\' </summary>\r\n        Public Sub New(ByVal query As ");

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write(")\r\n            MyBase.New(query)\r\n        End Sub\r\n");


    }

    internal override void WriteContextEntitySetProperty(string entitySetName, string entitySetFixedName, string originalEntitySetName, string entitySetElementTypeName, bool inContext)
    {

this.Write("        \'\'\'<summary>\r\n        \'\'\'There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(" in the schema.\r\n        \'\'\'</summary>\r\n        <Global.System.CodeDom.Compiler.G" +
        "eneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalEntitySetName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public ReadOnly Property ");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetFixedName));

this.Write("() As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

this.Write(")\r\n            Get\r\n");


        if (!inContext)
        {

this.Write("                If Not Me.IsComposable Then\r\n                    Throw New Global" +
        ".System.NotSupportedException(\"The previous function is not composable.\")\r\n     " +
        "           End If\r\n");


        }

this.Write("                If (Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(" Is Nothing) Then\r\n                    Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(" = ");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "MyBase" : "Context"));

this.Write(".CreateQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

this.Write(")(");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "\"" + originalEntitySetName + "\"" : "GetPath(\"" + originalEntitySetName + "\")"));

this.Write(")\r\n                End If\r\n                Return Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write("\r\n            End Get\r\n        End Property\r\n        <Global.System.CodeDom.Compi" +
        "ler.GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Private _");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(" As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetElementTypeName));

this.Write(")\r\n");


    }

    internal override void WriteContextSingletonProperty(string singletonName, string singletonFixedName, string originalSingletonName, string singletonElementTypeName, bool inContext)
    {

this.Write("        \'\'\'<summary>\r\n        \'\'\'There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write(" in the schema.\r\n        \'\'\'</summary>\r\n        <Global.System.CodeDom.Compiler.G" +
        "eneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalSingletonName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public ReadOnly Property ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonFixedName));

this.Write("() As ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

this.Write("\r\n            Get\r\n");


        if (!inContext)
        {

this.Write("                If Not Me.IsComposable Then\r\n                    Throw New Global" +
        ".System.NotSupportedException(\"The previous function is not composable.\")\r\n     " +
        "           End If\r\n");


        }

this.Write("                If (Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write(" Is Nothing) Then\r\n                    Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write(" = New ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "Me" : "Me.Context"));

this.Write(", ");

this.Write(this.ToStringHelper.ToStringWithCulture(inContext ? "\"" + originalSingletonName + "\"" : "GetPath(\"" + originalSingletonName + "\")"));

this.Write(")\r\n                End If\r\n                Return Me._");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write("\r\n            End Get\r\n        End Property\r\n        <Global.System.CodeDom.Compi" +
        "ler.GeneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Private _");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonName));

this.Write(" As ");

this.Write(this.ToStringHelper.ToStringWithCulture(singletonElementTypeName));

this.Write("\r\n");


    }

    internal override void WriteContextAddToEntitySetMethod(string entitySetName, string originalEntitySetName, string typeName, string parameterName)
    {

this.Write("        \'\'\'<summary>\r\n        \'\'\'There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write(" in the schema.\r\n        \'\'\'</summary>\r\n        <Global.System.CodeDom.Compiler.G" +
        "eneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Public Sub AddTo");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write("(ByVal ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(" As ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(")\r\n            Me.AddObject(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalEntitySetName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(")\r\n        End Sub\r\n");


    }

    internal override void WriteGeneratedEdmModel(string escapedEdmxString)
    {
        escapedEdmxString = escapedEdmxString.Replace("\r\n", "\" & _\r\n \"");

this.Write("        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData.C" +
        "lient.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Private MustInherit Class GeneratedEdmModel\r\n");


        if (this.context.ReferencesMap != null)
        {

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Private Shared ReferencesMap As Global.System.Collections.Gen" +
        "eric.Dictionary(Of String, String) = New Global.System.Collections.Generic.Dicti" +
        "onary(Of String, String) From\r\n                {\r\n");


            int count = this.context.ReferencesMap.Count();
            foreach(var reference in this.context.ReferencesMap)
            {

this.Write("                    {\"");

this.Write(this.ToStringHelper.ToStringWithCulture(reference.Key.OriginalString.Replace("\"", "\"\"")));

this.Write("\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(Utils.SerializeToString(reference.Value).Replace("\"", "\"\"").Replace("\r\n", "\" & _\r\n \"")));

this.Write("\"}");

this.Write(this.ToStringHelper.ToStringWithCulture((--count>0?",":"")));

this.Write("\r\n");


            }

this.Write("                }\r\n");


        }

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Private Shared ParsedModel As Global.Microsoft.OData.Edm.IEdm" +
        "Model = LoadModelFromString\r\n            <Global.System.CodeDom.Compiler.Generat" +
        "edCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Private Const Edmx As String = \"");

this.Write(this.ToStringHelper.ToStringWithCulture(escapedEdmxString));

this.Write("\"\r\n            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft." +
        "OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n            Public Shared Function GetInstance() As Global.Microsoft.ODat" +
        "a.Edm.IEdmModel\r\n                Return ParsedModel\r\n            End Function\r\n");


        if (this.context.ReferencesMap != null)
        {

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")>  _
            Private Shared Function getReferencedModelFromMap(ByVal uri As Global.System.Uri) As Global.System.Xml.XmlReader
                Dim referencedEdmx As String = Nothing
                If (ReferencesMap.TryGetValue(uri.OriginalString, referencedEdmx)) Then
                    Return CreateXmlReader(referencedEdmx)
                End If
                Return Nothing
            End Function
            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(""Microsoft.OData.Client.Design.T4"", """);

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")>  _
            Private Shared Function LoadModelFromString() As Global.Microsoft.OData.Edm.IEdmModel
                Dim reader As Global.System.Xml.XmlReader = CreateXmlReader(Edmx)
                Try
                    Return Global.Microsoft.OData.Edm.Csdl.CsdlReader.Parse(reader, AddressOf getReferencedModelFromMap)
                Finally
                    CType(reader,Global.System.IDisposable).Dispose
                End Try
            End Function
");


        }
        else
        {

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")>  _
            Private Shared Function LoadModelFromString() As Global.Microsoft.OData.Edm.IEdmModel
                Dim reader As Global.System.Xml.XmlReader = CreateXmlReader(Edmx)
                Try
                    Return Global.Microsoft.OData.Edm.Csdl.CsdlReader.Parse(reader)
                Finally
                    CType(reader,Global.System.IDisposable).Dispose
                End Try
            End Function
");


        }

this.Write("            <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.ODa" +
        "ta.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")>  _
            Private Shared Function CreateXmlReader(ByVal edmxToParse As String) As Global.System.Xml.XmlReader
                Return Global.System.Xml.XmlReader.Create(New Global.System.IO.StringReader(edmxToParse))
            End Function
        End Class
");


    }

    internal override void WriteClassEndForEntityContainer()
    {

this.Write("    End Class\r\n");


    }

    internal override void WriteSummaryCommentForStructuredType(string typeName)
    {

this.Write("    \'\'\'<summary>\r\n    \'\'\'There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(" in the schema.\r\n    \'\'\'</summary>\r\n");


    }

    internal override void WriteKeyPropertiesCommentAndAttribute(IEnumerable<string> keyProperties, string keyString)
    {

this.Write("    \'\'\'<KeyProperties>\r\n");


        foreach (string key in keyProperties)
        {

this.Write("    \'\'\'");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write("\r\n");


        } 

this.Write("    \'\'\'</KeyProperties>\r\n    <Global.Microsoft.OData.Client.Key(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(keyString));

this.Write("\")>  _\r\n");


    }

    internal override void WriteEntityTypeAttribute()
    {

this.Write("    <Global.Microsoft.OData.Client.EntityType()>  _\r\n");


    }

    internal override void WriteEntitySetAttribute(string entitySetName)
    {

this.Write("    <Global.Microsoft.OData.Client.EntitySet(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(entitySetName));

this.Write("\")>  _\r\n");


    }

    internal override void WriteEntityHasStreamAttribute()
    {

this.Write("    <Global.Microsoft.OData.Client.HasStream()>  _\r\n");


    }

    internal override void WriteClassStartForStructuredType(string abstractModifier, string typeName, string originalTypeName, string baseTypeName)
    {
        if (this.context.EnableNamingAlias)
    {

this.Write("    <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalTypeName));

this.Write("\")>  _\r\n");


        }

this.Write("    Partial Public");

this.Write(this.ToStringHelper.ToStringWithCulture(abstractModifier));

this.Write(" Class ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write("\r\n");


    }

    internal override void WriteSummaryCommentForStaticCreateMethod(string typeName)
    {

this.Write("        \'\'\'<summary>\r\n        \'\'\'Create a new ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(" object.\r\n        \'\'\'</summary>\r\n");


    }

    internal override void WriteParameterCommentForStaticCreateMethod(string parameterName, string propertyName)
    {

this.Write("        \'\'\'<param name=\"");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write("\">Initial value of ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

this.Write(".</param>\r\n");


    }

    internal override void WriteDeclarationStartForStaticCreateMethod(string typeName, string fixedTypeName)
    {

this.Write("        <Global.System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.OData.C" +
        "lient.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n        Public Shared Function Create");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write("(");



    }

    internal override void WriteParameterForStaticCreateMethod(string parameterTypeName, string parameterName, string parameterSeparater)
    {

this.Write("ByVal ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(" As ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterTypeName));

this.Write(this.ToStringHelper.ToStringWithCulture(parameterSeparater));


    }

    internal override void WriteDeclarationEndForStaticCreateMethod(string typeName, string instanceName)
    {
          
this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write("\r\n            Dim ");

this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

this.Write(" As ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write(" = New ");

this.Write(this.ToStringHelper.ToStringWithCulture(typeName));

this.Write("()\r\n");


    }

    internal override void  WriteParameterNullCheckForStaticCreateMethod(string parameterName)
    {

this.Write("            If (");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write(" Is Nothing) Then\r\n                Throw New Global.System.ArgumentNullException(" +
        "\"");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write("\")\r\n            End If\r\n");


    }

    internal override void WritePropertyValueAssignmentForStaticCreateMethod(string instanceName, string propertyName, string parameterName)
    {

this.Write("            ");

this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

this.Write(" = ");

this.Write(this.ToStringHelper.ToStringWithCulture(parameterName));

this.Write("\r\n");


    }

    internal override void WriteMethodEndForStaticCreateMethod(string instanceName)
    {

this.Write("            Return ");

this.Write(this.ToStringHelper.ToStringWithCulture(instanceName));

this.Write("\r\n        End Function\r\n");


    }

            internal override void WritePropertyForStructuredType(string propertyType, string originalPropertyName, string propertyName, string fixedPropertyName, string privatePropertyName, string propertyInitializationValue, bool writeOnPropertyChanged, bool writeRequiredPropertyAttribute, int? maxPropertyDataLength, Microsoft.OData.Edm.EdmReferentialConstraint foreignKey, bool isComplex)
    {

this.Write("        \'\'\'<summary>\r\n        \'\'\'There are no comments for Property ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

this.Write(" in the schema.\r\n        \'\'\'</summary>\r\n        <Global.System.CodeDom.Compiler.G" +
        "eneratedCodeAttribute(\"Microsoft.OData.Client.Design.T4\", \"");

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write("\")>  _\r\n");


        if (this.context.EnableNamingAlias || IdentifierMappings.ContainsKey(originalPropertyName))
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalPropertyName));

this.Write("\")>  _\r\n");


        }

this.WriteGeneratedCodeAttribute();

        if (writeRequiredPropertyAttribute)
        {
this.Write("        <Global.System.ComponentModel.DataAnnotations.RequiredAttribute(ErrorMessage = \"");
this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));
this.Write(" is required.\")>  _\r\n");
        }
        if (maxPropertyDataLength.GetValueOrDefault() > 0)
        {
            this.Write("        <global.System.ComponentModel.DataAnnotations.MaxLengthAttribute(" + maxPropertyDataLength.Value + ", ErrorMessage = \"");
            this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));
            this.Write(" must be less than " + maxPropertyDataLength + " characters.\")> _\r\n");
        }
        if (foreignKey != null)
        {
this.Write("        <global.System.ComponentModel.DataAnnotations.Schema.ForeignKeyAttribute(\"" + String.Join(",", foreignKey.PropertyPairs.Select(x => x.DependentProperty.Name)) + "\")> _\r\n");
        }

this.Write("        Public Property ");

this.Write(this.ToStringHelper.ToStringWithCulture(fixedPropertyName));

this.Write("() As ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyType));

this.Write("\r\n            Get\r\n                Return Me.");

this.Write(this.ToStringHelper.ToStringWithCulture(privatePropertyName));

this.Write("\r\n            End Get\r\n            Set\r\n");

        if (foreignKey == null)
        {
            this.WriteLine("                Me.On{0}Changing(value)", this.ToStringHelper.ToStringWithCulture(propertyName));
            this.WriteLine("                Me.{0} = value", this.ToStringHelper.ToStringWithCulture(privatePropertyName));
            this.WriteLine("                Me.On{0}Changed()", this.ToStringHelper.ToStringWithCulture(propertyName));
        }
        else
        {
            // Allow On{FK}Changing to cancel the object change process as well.
            this.WriteLine("                Me.On{0}Changing(value)", this.ToStringHelper.ToStringWithCulture(propertyName));
            foreach (var reference in foreignKey.PropertyPairs)
                this.WriteLine("                if(value != null) \r\n                    Me.On{0}Changing(value.{1}) \r\n                End If", this.ToStringHelper.ToStringWithCulture(reference.DependentProperty.Name), this.ToStringHelper.ToStringWithCulture(reference.PrincipalProperty.Name));
            this.WriteLine("                Me.{0} = value", this.ToStringHelper.ToStringWithCulture(privatePropertyName));
            this.WriteLine("                Me.On{0}Changed()", this.ToStringHelper.ToStringWithCulture(propertyName));
            foreach (var reference in foreignKey.PropertyPairs)
                this.WriteLine("                if(value != null) \r\n                    Me.{0} = value.{1} \r\n                End If", this.ToStringHelper.ToStringWithCulture(reference.DependentProperty.Name), this.ToStringHelper.ToStringWithCulture(reference.PrincipalProperty.Name));
        }

        if (writeOnPropertyChanged)
        {

this.Write("                Me.OnPropertyChanged(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalPropertyName));

this.Write("\")\r\n");


        }

this.Write("            End Set\r\n        End Property\r\n _");

this.WriteGeneratedCodeAttribute();


        string constructorString = string.Empty;
        if (!string.IsNullOrEmpty(propertyInitializationValue))
        {
            constructorString = " = " + propertyInitializationValue;
        }

this.Write("        Private ");

this.Write(this.ToStringHelper.ToStringWithCulture(privatePropertyName));

this.Write(" As ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyType));

this.Write(this.ToStringHelper.ToStringWithCulture(constructorString));

this.Write("\r\n        Partial Private Sub On");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

this.Write("Changing(ByVal value As ");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyType));

this.Write(")\r\n        End Sub\r\n        Partial Private Sub On");

this.Write(this.ToStringHelper.ToStringWithCulture(propertyName));

this.Write("Changed()\r\n        End Sub\r\n");


    }

    internal override void WriteINotifyPropertyChangedImplementation()
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' This event is raised when the value of the pro" +
        "perty is changed\r\n        \'\'\' </summary>\r\n _");
this.WriteGeneratedCodeAttribute();

this.Write(@"
        Public Event PropertyChanged As Global.System.ComponentModel.PropertyChangedEventHandler Implements Global.System.ComponentModel.INotifyPropertyChanged.PropertyChanged
        ''' <summary>
        ''' The value of the property is changed
        ''' </summary>
        ''' <param name=""property"">property name</param> _");
this.WriteGeneratedCodeAttribute();

this.Write(this.ToStringHelper.ToStringWithCulture(T4Version));

this.Write(@""")>  _
        Protected Overridable Sub OnPropertyChanged(ByVal [property] As String)
            If (Not (Me.PropertyChangedEvent) Is Nothing) Then
                RaiseEvent PropertyChanged(Me, New Global.System.ComponentModel.PropertyChangedEventArgs([property]))
            End If
        End Sub
");


    }

    internal override void WriteClassEndForStructuredType()
    {

this.Write("    End Class\r\n");


    }
    
    internal override void WriteEnumFlags()
    {

this.Write("    <Global.System.Flags()>\r\n");


    }

    internal override void WriteSummaryCommentForEnumType(string enumName)
    {

this.Write("    \'\'\'<summary>\r\n    \'\'\'There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(enumName));

this.Write(" in the schema.\r\n    \'\'\'</summary>\r\n");


    }

    internal override void WriteEnumDeclaration(string enumName, string originalEnumName, string underlyingType)
    {
        if (this.context.EnableNamingAlias)
    {

this.Write("    <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalEnumName));

this.Write("\")>  _\r\n");


        }

this.Write("    Public Enum ");

this.Write(this.ToStringHelper.ToStringWithCulture(enumName));

this.Write(this.ToStringHelper.ToStringWithCulture(underlyingType));

this.Write("\r\n");


    }

    internal override void WriteMemberForEnumType(string member, string originalMemberName, bool last)
    {
        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalMemberName));

this.Write("\")>  _\r\n");


        }

this.Write("        ");

this.Write(this.ToStringHelper.ToStringWithCulture(member));

this.Write("\r\n");


    }

    internal override void WriteEnumEnd()
    {

this.Write("    End Enum\r\n");


    }
    
    internal override void WriteFunctionImportReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string parameters, string parameterValues, bool isComposable, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")\r\n            Return Me.CreateFunctionQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")(\"\", \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(" ");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }
    internal override void WriteFunctionImportWithInputWrapperReturnCollectionResult(string functionName, string originalFunctionName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.WriteGeneratedCodeAttribute();

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write("request As " + inputWrapperTypeName);

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

if (useEntityReference)
{
    var temp = parameterNames.ToList();
    temp.Add("useEntityReference");
    parameterNames = temp.ToArray();
}

this.Write(") As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")\r\n            Return Me." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));

this.Write(")\r\n        End Function\r\n");

    }

    internal override void WriteFunctionImportReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write("\r\n            Return ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "New " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

this.Write("Me.CreateFunctionQuerySingle(");

this.Write(this.ToStringHelper.ToStringWithCulture("Of " + returnTypeName));

this.Write(")(\"\", \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

this.Write("\r\n        End Function\r\n");


    }

    internal override void WriteFunctionImportWithInputWrapperReturnSingleResult(string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string inputWrapperTypeName, string[] parameterNames, bool isReturnEntity, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");

        }
this.WriteGeneratedCodeAttribute();

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write("request As " + inputWrapperTypeName);

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

        if (useEntityReference)
        {
            var temp = parameterNames.ToList();
            temp.Add("useEntityReference");
            parameterNames = temp.ToArray();
        }

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write(")\r\n            Return Me." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));

this.Write(")\r\n        End Function\r\n");


    }

    internal override void WriteBoundFunctionInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write("Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")\r\n            Dim requestUri As Global.System.Uri = Nothing\r\n            Context" +
        ".TryGetUri(Me, requestUri)\r\n            Return Me.Context.CreateFunctionQuery(Of" +
        " ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")(\"\", String.Join(\"/\", Global.System.Linq.Enumerable.Select(Global.System.Linq.En" +
        "umerable.Skip(requestUri.Segments, Me.Context.BaseUri.Segments.Length), Function" +
        "(s) s.Trim(\"/\"C))) + \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }
    internal override void WriteBoundFunctionWithInputWrapperInEntityTypeReturnCollectionResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write("Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write("request As" + inputWrapperTypeName);

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

if (useEntityReference)
{
    var temp = parameterNames.ToList();
    temp.Add("useEntityReference");
    parameterNames = temp.ToArray();
}

this.Write(") As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")\r\n            Return Me." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));

this.Write(")\r\n        End Function\r\n");

    }

    internal override void WriteBoundFunctionInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write("Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write("\r\n            Dim requestUri As Global.System.Uri = Nothing\r\n            Context." +
        "TryGetUri(Me, requestUri)\r\n            Return ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "New " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

this.Write("Me.Context.CreateFunctionQuerySingle(");

this.Write(this.ToStringHelper.ToStringWithCulture("Of " + returnTypeName));

this.Write(")(String.Join(\"/\", Global.System.Linq.Enumerable.Select(Global.System.Linq.Enumer" +
        "able.Skip(requestUri.Segments, Me.Context.BaseUri.Segments.Length), Function(s) " +
        "s.Trim(\"/\"C))), \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

this.Write("\r\n        End Function\r\n");


    }
    internal override void WriteBoundFunctionWithInputWrapperInEntityTypeReturnSingleResult(bool hideBaseMethod, string functionName, string originalFunctionName, string returnTypeName, string returnTypeNameWithSingleSuffix, string inputWrapperTypeName, string[] parameterNames, string fullNamespace, bool isReturnEntity, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write("Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(");

this.Write("request As " + inputWrapperTypeName);

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

if (useEntityReference)
{
    var temp = parameterNames.ToList();
    temp.Add("useEntityReference");
    parameterNames = temp.ToArray();
}

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write("\r\n            Return Me." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));

this.Write(")\r\n        End Function\r\n");

    }
    
    internal override void WriteActionImport(string actionName, string originalActionName, string returnTypeName, string parameters, string parameterValues)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(Me, Me.BaseUri.OriginalString.Trim(\"/\"C) + \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\"");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }
    internal override void WriteActionImportWithInputWrapper(string actionName, string originalActionName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")>  _\r\n");


        }
this.WriteGeneratedCodeAttribute();
                    
this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write("(");

this.Write("request As " + inputWrapperTypeName);

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")\r\n            Return Me." + this.ToStringHelper.ToStringWithCulture(actionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));

this.Write(")\r\n        End Function\r\n");

    }

    internal override void WriteBoundActionInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string parameters, string fullNamespace, string parameterValues)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write("Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write("(");

this.Write(this.ToStringHelper.ToStringWithCulture(parameters));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(@"
            Dim resource As Global.Microsoft.OData.Client.EntityDescriptor = Context.EntityTracker.TryGetEntityDescriptor(Me)
            If resource Is Nothing Then
                Throw New Global.System.Exception(""cannot find entity"")
            End If

            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(Me.Context, resource.EditLink.OriginalString.Trim(\"/\"C) + \"/");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\"");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }
    internal override void WriteBoundActionWithInputWrapperInEntityType(bool hideBaseMethod, string actionName, string originalActionName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public ");

this.Write(this.ToStringHelper.ToStringWithCulture(hideBaseMethod ? this.OverloadsModifier : string.Empty));

this.Write("Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write("(");

this.Write("request As " + inputWrapperTypeName);

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            Return Me." + this.ToStringHelper.ToStringWithCulture(actionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));

this.Write(")\r\n        End Function\r\n");

    }

    internal override void WriteExtensionMethodsStart()
    {

this.Write("    \'\'\' <summary>\r\n    \'\'\' Class containing all extension methods\r\n    \'\'\' </summ" +
        "ary>\r\n    Public Module ExtensionMethods\r\n");


    }

    internal override void WriteExtensionMethodsEnd()
    {

this.Write("    End Module\r\n");


    }

    internal override void WriteByKeyMethods(string entityTypeName, string returnTypeName, IEnumerable<string> keys, string keyParameters, string keyDictionaryItems)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' Get an entity of type ");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write(" as ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(@" specified by key from an entity set
        ''' </summary>
        ''' <param name=""_source"">source entity set</param>
        ''' <param name=""keys"">dictionary with the names and values of keys</param>
        <Global.System.Runtime.CompilerServices.Extension()>
        Public Function ByKey(ByVal _source As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write("), ByVal keys As Global.System.Collections.Generic.Dictionary(Of String, Object))" +
        " As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, _source.GetKeyPath(Global.Microsoft.OData.Client.Serializer.GetKe" +
        "yString(_source.Context, keys)))\r\n        End Function\r\n        \'\'\' <summary>\r\n  " +
        "      \'\'\' Get an entity of type ");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write(" as ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(" specified by key from an entity set\r\n        \'\'\' </summary>\r\n        \'\'\' <param " +
        "name=\"_source\">source entity set</param>\r\n");


        foreach (var key in keys)
        {

this.Write("        \'\'\' <param name=\"");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write("\">The value of ");

this.Write(this.ToStringHelper.ToStringWithCulture(key));

this.Write("</param>\r\n");


        }

this.Write("        <Global.System.Runtime.CompilerServices.Extension()>\r\n        Public Func" +
        "tion ByKey(ByVal _source As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(entityTypeName));

this.Write("),\r\n            ");

this.Write(this.ToStringHelper.ToStringWithCulture(keyParameters));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            Dim keys As Global.System.Collections.Generic.Dictionary(Of String," +
        " Object) = New Global.System.Collections.Generic.Dictionary(Of String, Object)()" +
        " From\r\n            {\r\n                ");

this.Write(this.ToStringHelper.ToStringWithCulture(keyDictionaryItems));

this.Write("\r\n            }\r\n            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, _source.GetKeyPath(Global.Microsoft.OData.Client.Serializer.GetKe" +
        "yString(_source.Context, keys)))\r\n        End Function\r\n");


    }

    internal override void WriteCastToMethods(string baseTypeName, string derivedTypeName, string derivedTypeFullName, string returnTypeName)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' Cast an entity of type ");

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write(" to its derived type ");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

this.Write("\r\n        \'\'\' </summary>\r\n        \'\'\' <param name=\"_source\">source entity</param>\r" +
        "\n        <Global.System.Runtime.CompilerServices.Extension()>\r\n        Public " +
        "Function CastTo");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeName));

this.Write("(ByVal _source As Global.Microsoft.OData.Client.DataServiceQuerySingle(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(baseTypeName));

this.Write(")) As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            Dim query As Global.Microsoft.OData.Client.DataServiceQuerySingle(O" +
        "f ");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

this.Write(") = _source.CastTo(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(derivedTypeFullName));

this.Write(")()\r\n            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, query.GetPath(Nothing))\r\n        End Function\r\n");


    }

    internal override void WriteBoundFunctionReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool isReturnEntity, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n        <Global.System.Runtime.CompilerS" +
        "ervices.Extension()>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(ByVal _source As ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write("\r\n            If Not _source.IsComposable Then\r\n                Throw New Global.S" +
        "ystem.NotSupportedException(\"The previous function is not composable.\")\r\n       " +
        "     End If\r\n            \r\n            Return ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? "New " + returnTypeNameWithSingleSuffix + "(" : string.Empty));

this.Write("_source.CreateFunctionQuerySingle(");

this.Write(this.ToStringHelper.ToStringWithCulture("Of " + returnTypeName));

this.Write(")(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? ")" : string.Empty));

this.Write("\r\n        End Function\r\n");


    }
    internal override void WriteBoundFunctionWithInputWrapperReturnSingleResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string returnTypeNameWithSingleSuffix, string inputWrapperTypeName, string[] parameterNames, string fullNamespace, bool isReturnEntity, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n        <Global.System.Runtime.CompilerS" +
        "ervices.Extension()>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(ByVal _source As ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

this.Write(", request As " + inputWrapperTypeName);

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

        if (useEntityReference)
        {
            var temp = parameterNames.ToList();
            temp.Add("useEntityReference");
            parameterNames = temp.ToArray();
        }

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(isReturnEntity ? returnTypeNameWithSingleSuffix : string.Format(this.DataServiceQuerySingleStructureTemplate, returnTypeName)));

this.Write(")\r\n            Return _source." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));

this.Write(")\r\n        End Function\r\n");

}

    internal override void WriteBoundFunctionReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string parameters, string fullNamespace, string parameterValues, bool isComposable, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n        <Global.System.Runtime.CompilerS" +
        "ervices.Extension()>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(ByVal _source As ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

this.Write(") As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")\r\n            If Not _source.IsComposable Then\r\n                Throw New Global." +
        "System.NotSupportedException(\"The previous function is not composable.\")\r\n      " +
        "      End If\r\n            \r\n            Return _source.CreateFunctionQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\", ");

this.Write(this.ToStringHelper.ToStringWithCulture(isComposable));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }
    internal override void WriteBoundFunctionWithInputWrapperReturnCollectionResultAsExtension(string functionName, string originalFunctionName, string boundTypeName, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace, bool useEntityReference)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n        <Global.System.Runtime.CompilerS" +
        "ervices.Extension()>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalFunctionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(functionName));

this.Write("(ByVal _source As ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundTypeName));

this.Write(", request As" + inputWrapperTypeName);

this.Write(this.ToStringHelper.ToStringWithCulture(useEntityReference ? ", Optional ByVal useEntityReference As Boolean = False" : string.Empty));

if (useEntityReference)
{
    var temp = parameterNames.ToList();
    temp.Add("useEntityReference");
    parameterNames = temp.ToArray();
}

this.Write(") As Global.Microsoft.OData.Client.DataServiceQuery(Of ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write(")\r\n            Return _source." + this.ToStringHelper.ToStringWithCulture(functionName) + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)));

this.Write(")\r\n        End Function\r\n");

}

    internal override void WriteBoundActionAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string parameters, string fullNamespace, string parameterValues)
    {

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n        <Global.System.Runtime.CompilerS" +
        "ervices.Extension()>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(this.ToStringHelper.ToStringWithCulture(actionName));

this.Write("(ByVal _source As ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundSourceType));

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameters) ? string.Empty : ", " + parameters));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            If Not _source.IsComposable Then\r\n                Throw New Global.S" +
        "ystem.NotSupportedException(\"The previous function is not composable.\")\r\n       " +
        "     End If\r\n            Return New ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("(_source.Context, _source.AppendRequestUri(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(fullNamespace));

this.Write(".");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")");

this.Write(this.ToStringHelper.ToStringWithCulture(string.IsNullOrEmpty(parameterValues) ? string.Empty : ", " + parameterValues));

this.Write(")\r\n        End Function\r\n");


    }
    internal override void WriteBoundActionWithInputWrapperAsExtension(string actionName, string originalActionName, string boundSourceType, string returnTypeName, string inputWrapperTypeName, string[] parameterNames, string fullNamespace)
    {
string parsedActionName = this.ToStringHelper.ToStringWithCulture(actionName);

this.Write("        \'\'\' <summary>\r\n        \'\'\' There are no comments for ");

this.Write(parsedActionName);

this.Write(" in the schema.\r\n        \'\'\' </summary>\r\n        <Global.System.Runtime.CompilerS" +
        "ervices.Extension()>\r\n");


        if (this.context.EnableNamingAlias)
        {

this.Write("        <Global.Microsoft.OData.Client.OriginalNameAttribute(\"");

this.Write(this.ToStringHelper.ToStringWithCulture(originalActionName));

this.Write("\")>  _\r\n");


        }

this.Write("        Public Function ");

this.Write(parsedActionName);

this.Write("(ByVal _source As ");

this.Write(this.ToStringHelper.ToStringWithCulture(boundSourceType));

this.Write(this.ToStringHelper.ToStringWithCulture(", request As " + inputWrapperTypeName));

this.Write(") As ");

this.Write(this.ToStringHelper.ToStringWithCulture(returnTypeName));

this.Write("\r\n            Return _source." + parsedActionName + "(" + String.Join(", ", parameterNames.Select(x => "request." + x)) + ")");

this.Write(")\r\n        End Function\r\n");


    }

    internal override void WriteNamespaceEnd()
    {

this.Write("End Namespace\r\n");


    }
}

    }
#region Base class
    /// <summary>
    /// Base class for this transformation
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "14.0.0.0")]
    internal class ODataT4CodeGeneratorBase
    {
#region Fields
        private global::System.Text.StringBuilder generationEnvironmentField;
        private global::System.CodeDom.Compiler.CompilerErrorCollection errorsField;
        private global::System.Collections.Generic.List<int> indentLengthsField;
        private string currentIndentField = "";
        private bool endsWithNewline;
        private global::System.Collections.Generic.IDictionary<string, object> sessionField;
#endregion
#region Properties
        /// <summary>
        /// The string builder that generation-time code is using to assemble generated output
        /// </summary>
        protected System.Text.StringBuilder GenerationEnvironment
        {
            get
            {
                if ((this.generationEnvironmentField == null))
                {
                    this.generationEnvironmentField = new global::System.Text.StringBuilder();
                }
                return this.generationEnvironmentField;
            }
            set => this.generationEnvironmentField = value;
        }
        /// <summary>
        /// The error collection for the generation process
        /// </summary>
        public System.CodeDom.Compiler.CompilerErrorCollection Errors
        {
            get
            {
                if ((this.errorsField == null))
                {
                    this.errorsField = new global::System.CodeDom.Compiler.CompilerErrorCollection();
                }
                return this.errorsField;
            }
        }
        /// <summary>
        /// A list of the lengths of each indent that was added with PushIndent
        /// </summary>
        private System.Collections.Generic.List<int> indentLengths
        {
            get
            {
                if ((this.indentLengthsField == null))
                {
                    this.indentLengthsField = new global::System.Collections.Generic.List<int>();
                }
                return this.indentLengthsField;
            }
        }
        /// <summary>
        /// Gets the current indent we use when adding lines to the output
        /// </summary>
        public string CurrentIndent => this.currentIndentField;

        /// <summary>
        /// Current transformation session
        /// </summary>
        public virtual global::System.Collections.Generic.IDictionary<string, object> Session
        {
            get => this.sessionField;
            set => this.sessionField = value;
        }
#endregion
#region Transform-time helpers
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void Write(string textToAppend)
        {
            if (string.IsNullOrEmpty(textToAppend))
            {
                return;
            }
            // If we're starting off, or if the previous text ended with a newline,
            // we have to append the current indent first.
            if (((this.GenerationEnvironment.Length == 0) 
                        || this.endsWithNewline))
            {
                this.GenerationEnvironment.Append(this.currentIndentField);
                this.endsWithNewline = false;
            }
            // Check if the current text ends with a newline
            if (textToAppend.EndsWith(global::System.Environment.NewLine, global::System.StringComparison.CurrentCulture))
            {
                this.endsWithNewline = true;
            }
            // This is an optimization. If the current indent is "", then we don't have to do any
            // of the more complex stuff further down.
            if ((this.currentIndentField.Length == 0))
            {
                this.GenerationEnvironment.Append(textToAppend);
                return;
            }
            // Everywhere there is a newline in the text, add an indent after it
            textToAppend = textToAppend.Replace(global::System.Environment.NewLine, (global::System.Environment.NewLine + this.currentIndentField));
            // If the text ends with a newline, then we should strip off the indent added at the very end
            // because the appropriate indent will be added when the next time Write() is called
            if (this.endsWithNewline)
            {
                this.GenerationEnvironment.Append(textToAppend, 0, (textToAppend.Length - this.currentIndentField.Length));
            }
            else
            {
                this.GenerationEnvironment.Append(textToAppend);
            }
        }
        /// <summary>
        /// Write text directly into the generated output
        /// </summary>
        public void WriteLine(string textToAppend)
        {
            this.Write(textToAppend);
            this.GenerationEnvironment.AppendLine();
            this.endsWithNewline = true;
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void Write(string format, params object[] args)
        {
            this.Write(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Write formatted text directly into the generated output
        /// </summary>
        public void WriteLine(string format, params object[] args)
        {
            this.WriteLine(string.Format(global::System.Globalization.CultureInfo.CurrentCulture, format, args));
        }
        /// <summary>
        /// Raise an error
        /// </summary>
        public void Error(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError
            {
                ErrorText = message
            };
            this.Errors.Add(error);
        }
        /// <summary>
        /// Raise a warning
        /// </summary>
        public void Warning(string message)
        {
            System.CodeDom.Compiler.CompilerError error = new global::System.CodeDom.Compiler.CompilerError
            {
                ErrorText = message, IsWarning = true
            };
            this.Errors.Add(error);
        }
        /// <summary>
        /// Increase the indent
        /// </summary>
        public void PushIndent(string indent)
        {
            if ((indent == null))
            {
                throw new global::System.ArgumentNullException("indent");
            }
            this.currentIndentField = (this.currentIndentField + indent);
            this.indentLengths.Add(indent.Length);
        }
        /// <summary>
        /// Remove the last indent that was added with PushIndent
        /// </summary>
        public string PopIndent()
        {
            string returnValue = "";
            if ((this.indentLengths.Count > 0))
            {
                int indentLength = this.indentLengths[(this.indentLengths.Count - 1)];
                this.indentLengths.RemoveAt((this.indentLengths.Count - 1));
                if ((indentLength > 0))
                {
                    returnValue = this.currentIndentField.Substring((this.currentIndentField.Length - indentLength));
                    this.currentIndentField = this.currentIndentField.Remove((this.currentIndentField.Length - indentLength));
                }
            }
            return returnValue;
        }
        /// <summary>
        /// Remove any indentation
        /// </summary>
        public void ClearIndent()
        {
            this.indentLengths.Clear();
            this.currentIndentField = "";
        }
#endregion
#region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get => this.formatProviderField;
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        /// <summary>
        /// Helper to produce culture-oriented representation of an object as a string
        /// </summary>
        public ToStringInstanceHelper ToStringHelper => this.toStringHelperField;

#endregion
    }
#endregion
}
